import jwt from 'jsonwebtoken';
const Config = require('../../config/webbox.config');
import CodeEmbed from '../models/codeEmbed';
/**
 * The pages controller handles are normal views without special logic.
 */

module.exports = {
  index: function (request, reply) {
    reply.view('index', {
      user: request.pre.user
    });
  },
  imprint: function (request, reply) {
    reply.view('imprint', {
      user: request.pre.user
    });
  },
  privacy: function (request, reply) {
    reply.view('privacy', {
      user: request.pre.user
    });
  },
  embed: function (request, reply) {
    // ToDo: just a quick test
    const secret = 'ItsASecretToEverybody!';

    let authToken = jwt.sign({
      username: request.pre.user.username
    }, secret);

    let meta = CodeEmbed.getDefaultMeta('PythonTest');
    let ce = new CodeEmbed({
      meta: meta,
      code: {
        'main.py': 'import os\n\nprint(os.environ.get(\'PYTHONPATH\'))\nprint(os.environ.get(\'MPLBACKEND\'))\n\nt = 3\ng = 9.81\n\nh = 0.5 * g * t**2\n\nprint(\"h(t) = %d\" % h)\n\nimport matplotlib.pyplot as pp\nimport numpy as np\n\nt = np.linspace(0, 10, 10)  # make a list of values from 0 to 10\nh = 0.5 * g * t**2 # calculate h for each value in t (h is also a list)\n\n# plot h and t\npp.plot(h, t, \"--ro\", linewidth=3, markersize=6, dash_capstyle=\"projecting\", markerfacecolor=\"b\");\npp.title(\"Free Fall\")\npp.xlabel(\"t in seconds\")\npp.ylabel(\"h in meters\")\npp.show()',
        'data.txt': 'test\ntest2\ntest3\n',
        'backend_sb.py': '#http:\/\/stackoverflow.com\/a\/32988875\/1602537\n\"\"\"\nTrinket backend to override plt.show() with plt.savefig().\n\"\"\"\n\nfrom __future__ import (absolute_import, division, print_function,\n                        unicode_literals)\n\nfrom matplotlib.externals import six\n\nimport matplotlib\nfrom matplotlib.backends.backend_agg import new_figure_manager, FigureCanvasAgg\nfrom matplotlib._pylab_helpers import Gcf\nfrom matplotlib.backend_bases import RendererBase, GraphicsContextBase,\\\n     FigureManagerBase, FigureCanvasBase\nfrom matplotlib.figure import Figure\nfrom matplotlib.transforms import Bbox\nimport io\nimport os\nimport sys\n\n\n########################################################################\n#\n# The following functions and classes are for pylab and implement\n# window\/figure managers, etc...\n#\n########################################################################\n\ndef show():\n    for manager in Gcf.get_all_fig_managers():\n        canvas = FigureCanvasAgg(manager.canvas.figure)\n\n\n        # now the filedescriptor 3 must exist\n        try:\n            fd = os.fdopen(3, \'wb\')\n            fd.write(b\'STARTIMGAGE\')\n            fd.flush()\n            canvas.print_png(fd)\n            fd.flush()\n            fd.write(b\'ENDIMAGE\')\n            fd.flush()\n            fd.close()\n        except e:\n            print(\'An error occured while sending the image to your browser.\')\n            \n\n########################################################################\n#\n# Now just provide the standard names that backend.__init__ is expecting\n#\n########################################################################\n\nFigureCanvas = FigureCanvasAgg',
        'wturtle.py': '#\n# turtle.py: a Tkinter based turtle graphics module for Python\n# Version 1.1b - 4. 5. 2009\n#\n# Copyright (C) 2006 - 2010  Gregor Lingl\n# email: glingl@aon.at\n#\n# This software is provided \'as-is\', without any express or implied\n# warranty.  In no event will the authors be held liable for any damages\n# arising from the use of this software.\n#\n# Permission is granted to anyone to use this software for any purpose,\n# including commercial applications, and to alter it and redistribute it\n# freely, subject to the following restrictions:\n#\n# 1. The origin of this software must not be misrepresented; you must not\n#    claim that you wrote the original software. If you use this software\n#    in a product, an acknowledgment in the product documentation would be\n#    appreciated but is not required.\n# 2. Altered source versions must be plainly marked as such, and must not be\n#    misrepresented as being the original software.\n# 3. This notice may not be removed or altered from any source distribution.\n\n\n\"\"\"\nTurtle graphics is a popular way for introducing programming to\nkids. It was part of the original Logo programming language developed\nby Wally Feurzig and Seymour Papert in 1966.\nImagine a robotic turtle starting at (0, 0) in the x-y plane. After an ``import turtle``, give it\nthe command turtle.forward(15), and it moves (on-screen!) 15 pixels in\nthe direction it is facing, drawing a line as it moves. Give it the\ncommand turtle.right(25), and it rotates in-place 25 degrees clockwise.\nBy combining together these and similar commands, intricate shapes and\npictures can easily be drawn.\n----- turtle.py\nThis module is an extended reimplementation of turtle.py from the\nPython standard distribution up to Python 2.5. (See: http:\/\/www.python.org)\nIt tries to keep the merits of turtle.py and to be (nearly) 100%\ncompatible with it. This means in the first place to enable the\nlearning programmer to use all the commands, classes and methods\ninteractively when using the module from within IDLE run with\nthe -n switch.\nRoughly it has the following features added:\n- Better animation of the turtle movements, especially of turning the\n  turtle. So the turtles can more easily be used as a visual feedback\n  instrument by the (beginning) programmer.\n- Different turtle shapes, gif-images as turtle shapes, user defined\n  and user controllable turtle shapes, among them compound\n  (multicolored) shapes. Turtle shapes can be stretched and tilted, which\n  makes turtles very versatile geometrical objects.\n- Fine control over turtle movement and screen updates via delay(),\n  and enhanced tracer() and speed() methods.\n- Aliases for the most commonly used commands, like fd for forward etc.,\n  following the early Logo traditions. This reduces the boring work of\n  typing long sequences of commands, which often occur in a natural way\n  when kids try to program fancy pictures on their first encounter with\n  turtle graphics.\n- Turtles now have an undo()-method with configurable undo-buffer.\n- Some simple commands\/methods for creating event driven programs\n  (mouse-, key-, timer-events). Especially useful for programming games.\n- A scrollable Canvas class. The default scrollable Canvas can be\n  extended interactively as needed while playing around with the turtle(s).\n- A TurtleScreen class with methods controlling background color or\n  background image, window and canvas size and other properties of the\n  TurtleScreen.\n- There is a method, setworldcoordinates(), to install a user defined\n  coordinate-system for the TurtleScreen.\n- The implementation uses a 2-vector class named Vec2D, derived from tuple.\n  This class is public, so it can be imported by the application programmer,\n  which makes certain types of computations very natural and compact.\n- Appearance of the TurtleScreen and the Turtles at startup\/import can be\n  configured by means of a turtle.cfg configuration file.\n  The default configuration mimics the appearance of the old turtle module.\n- If configured appropriately the module reads in docstrings from a docstring\n  dictionary in some different language, supplied separately  and replaces\n  the English ones by those read in. There is a utility function\n  write_docstringdict() to write a dictionary with the original (English)\n  docstrings to disc, so it can serve as a template for translations.\nBehind the scenes there are some features included with possible\nextensions in mind. These will be commented and documented elsewhere.\n\"\"\"\n\n_ver = \"turtle 1.1b- - for Python 3.1   -  4. 5. 2009\"\n\n# print(_ver)\n\nimport types\nimport math\nimport time\nimport inspect\nimport sys\nimport builtins\n\nfrom os.path import isfile, split, join\nfrom copy import deepcopy\n\n_tg_classes = [\'TurtleScreen\', \'Screen\',\n               \'RawTurtle\', \'Turtle\', \'RawPen\', \'Pen\', \'Shape\', \'Vec2D\']\n_tg_screen_functions = [\'addshape\', \'bgcolor\', \'bgpic\', \'bye\',\n        \'clearscreen\', \'colormode\', \'delay\', \'exitonclick\', \'getcanvas\',\n        \'getshapes\', \'listen\', \'mainloop\', \'mode\', \'numinput\',\n        \'onkey\', \'onkeypress\', \'onkeyrelease\', \'onscreenclick\', \'ontimer\',\n        \'register_shape\', \'resetscreen\', \'screensize\', \'setup\',\n        \'setworldcoordinates\', \'textinput\', \'title\', \'tracer\', \'turtles\', \'update\',\n        \'window_height\', \'window_width\']\n_tg_turtle_functions = [\'back\', \'backward\', \'begin_fill\', \'begin_poly\', \'bk\',\n        \'circle\', \'clear\', \'clearstamp\', \'clearstamps\', \'clone\', \'color\',\n        \'degrees\', \'distance\', \'dot\', \'down\', \'end_fill\', \'end_poly\', \'fd\',\n        \'fillcolor\', \'filling\', \'forward\', \'get_poly\', \'getpen\', \'getscreen\', \'get_shapepoly\',\n        \'getturtle\', \'goto\', \'heading\', \'hideturtle\', \'home\', \'ht\', \'isdown\',\n        \'isvisible\', \'left\', \'lt\', \'onclick\', \'ondrag\', \'onrelease\', \'pd\',\n        \'pen\', \'pencolor\', \'pendown\', \'pensize\', \'penup\', \'pos\', \'position\',\n        \'pu\', \'radians\', \'right\', \'reset\', \'resizemode\', \'rt\',\n        \'seth\', \'setheading\', \'setpos\', \'setposition\', \'settiltangle\',\n        \'setundobuffer\', \'setx\', \'sety\', \'shape\', \'shapesize\', \'shapetransform\', \'shearfactor\', \'showturtle\',\n        \'speed\', \'st\', \'stamp\', \'tilt\', \'tiltangle\', \'towards\',\n        \'turtlesize\', \'undo\', \'undobufferentries\', \'up\', \'width\',\n        \'write\', \'xcor\', \'ycor\']\n_tg_utilities = [\'write_docstringdict\', \'done\']\n\n__all__ = (_tg_classes + _tg_screen_functions + _tg_turtle_functions +\n           _tg_utilities + [\'Terminator\']) # + _math_functions)\n\n_alias_list = [\'addshape\', \'backward\', \'bk\', \'fd\', \'ht\', \'lt\', \'pd\', \'pos\',\n               \'pu\', \'rt\', \'seth\', \'setpos\', \'setposition\', \'st\',\n               \'turtlesize\', \'up\', \'width\']\n\n_CFG = {\"width\" : 0.5,               # Screen\n        \"height\" : 0.75,\n        \"canvwidth\" : 400,\n        \"canvheight\": 300,\n        \"leftright\": None,\n        \"topbottom\": None,\n        \"mode\": \"standard\",          # TurtleScreen\n        \"colormode\": 1.0,\n        \"delay\": 10,\n        \"undobuffersize\": 1000,      # RawTurtle\n        \"shape\": \"classic\",\n        \"pencolor\" : \"black\",\n        \"fillcolor\" : \"black\",\n        \"resizemode\" : \"noresize\",\n        \"visible\" : True,\n        \"language\": \"english\",        # docstrings\n        \"exampleturtle\": \"turtle\",\n        \"examplescreen\": \"screen\",\n        \"title\": \"Python Turtle Graphics\",\n        \"using_IDLE\": False\n       }\n\ndef config_dict(filename):\n    \"\"\"Convert content of config-file into dictionary.\"\"\"\n    with open(filename, \"r\") as f:\n        cfglines = f.readlines()\n    cfgdict = {}\n    for line in cfglines:\n        line = line.strip()\n        if not line or line.startswith(\"#\"):\n            continue\n        try:\n            key, value = line.split(\"=\")\n        except:\n            print(\"Bad line in config-file %s:\\n%s\" % (filename,line))\n            continue\n        key = key.strip()\n        value = value.strip()\n        if value in [\"True\", \"False\", \"None\", \"\'\'\", \'\"\"\']:\n            value = eval(value)\n        else:\n            try:\n                if \".\" in value:\n                    value = float(value)\n                else:\n                    value = int(value)\n            except:\n                pass # value need not be converted\n        cfgdict[key] = value\n    return cfgdict\n\ndef readconfig(cfgdict):\n    \"\"\"Read config-files, change configuration-dict accordingly.\n    If there is a turtle.cfg file in the current working directory,\n    read it from there. If this contains an importconfig-value,\n    say \'myway\', construct filename turtle_mayway.cfg else use\n    turtle.cfg and read it from the import-directory, where\n    turtle.py is located.\n    Update configuration dictionary first according to config-file,\n    in the import directory, then according to config-file in the\n    current working directory.\n    If no config-file is found, the default configuration is used.\n    \"\"\"\n    default_cfg = \"turtle.cfg\"\n    cfgdict1 = {}\n    cfgdict2 = {}\n    if isfile(default_cfg):\n        cfgdict1 = config_dict(default_cfg)\n    if \"importconfig\" in cfgdict1:\n        default_cfg = \"turtle_%s.cfg\" % cfgdict1[\"importconfig\"]\n    try:\n        head, tail = split(__file__)\n        cfg_file2 = join(head, default_cfg)\n    except:\n        cfg_file2 = \"\"\n    if isfile(cfg_file2):\n        cfgdict2 = config_dict(cfg_file2)\n    _CFG.update(cfgdict2)\n    _CFG.update(cfgdict1)\n\ntry:\n    readconfig(_CFG)\nexcept:\n    print (\"No configfile read, reason unknown\")\n\n\nclass Vec2D(tuple):\n    \"\"\"A 2 dimensional vector class, used as a helper class\n    for implementing turtle graphics.\n    May be useful for turtle graphics programs also.\n    Derived from tuple, so a vector is a tuple!\n    Provides (for a, b vectors, k number):\n       a+b vector addition\n       a-b vector subtraction\n       a*b inner product\n       k*a and a*k multiplication with scalar\n       |a| absolute value of a\n       a.rotate(angle) rotation\n    \"\"\"\n    def __new__(cls, x, y):\n        return tuple.__new__(cls, (x, y))\n    def __add__(self, other):\n        return Vec2D(self[0]+other[0], self[1]+other[1])\n    def __mul__(self, other):\n        if isinstance(other, Vec2D):\n            return self[0]*other[0]+self[1]*other[1]\n        return Vec2D(self[0]*other, self[1]*other)\n    def __rmul__(self, other):\n        if isinstance(other, int) or isinstance(other, float):\n            return Vec2D(self[0]*other, self[1]*other)\n    def __sub__(self, other):\n        return Vec2D(self[0]-other[0], self[1]-other[1])\n    def __neg__(self):\n        return Vec2D(-self[0], -self[1])\n    def __abs__(self):\n        return (self[0]**2 + self[1]**2)**0.5\n    def rotate(self, angle):\n        \"\"\"rotate self counterclockwise by angle\n        \"\"\"\n        perp = Vec2D(-self[1], self[0])\n        angle = angle * math.pi \/ 180.0\n        c, s = math.cos(angle), math.sin(angle)\n        return Vec2D(self[0]*c+perp[0]*s, self[1]*c+perp[1]*s)\n    def __getnewargs__(self):\n        return (self[0], self[1])\n    def __repr__(self):\n        return \"(%.2f,%.2f)\" % self\n\n\n##############################################################################\n### From here up to line    : Tkinter - Interface for turtle.py            ###\n### May be replaced by an interface to some different graphics toolkit     ###\n##############################################################################\nimport time\nimport os\nimport json\n\n# guaranteed to exist in Tk\nnamedcolors = [\"white\", \"black\", \"red\", \"green\", \"blue\", \"cyan\", \"yellow\", \"magenta\"]\n\nclass WebImage:\n    pass\n\nclass BlankImage(WebImage):\n    pass\n\nclass Event:\n    def __init__(self, d):\n        for k,v in d.items():\n            setattr(self, k, v)\n\n# output limit 16MiB\noutput_capacity = 16*1024*1024\nimport io\nclass WebCommunication:\n    def __init__(self):\n      self.fd_out = io.FileIO(4, \'wb\')\n      self.fd_in = io.FileIO(5, \'rb\')\n\n      self.buf = b\'\'\n      self.canvas = []\n      self.messages = []\n      self.capacity = output_capacity\n\n    def write(self, data, name):\n        self.sendpickle({\'cmd\':\'write\',\n                      \'stream\':name,\n                      \'data\':data\n                      })\n    def input(self, prompt=\'\'):\n        self.sendpickle({\'cmd\':\'input\',\n                         \'stream\':\'stdin\',\n                         \'data\':prompt})\n        result = self.receivemsg()\n        return result[\'data\']\n\n    # internal\n    def sendpickle(self, data):\n        data = json.dumps(data) + \"\\n\\r\"\n        self.capacity -= len(data)\n        if self.capacity < 0:\n            data = json.dumps({\'cmd\':\'stop\',\n                                 \'timedout\':True}, 2)\n            print(data)\n            self.fd_out.write(bytes(data, \"utf-8\"))\n            raise SystemExit\n        print(data)\n        self.fd_out.write(bytes(data, \"utf-8\"))\n\n    def debug(message):\n        self.sendpickle({\n            \'cmd\': \'debug\',\n            \'data\': message,\n            \'char\': chr(message)\n        })\n\n    def _readline(self):\n        buffer = []\n        print(\'_readline\')\n        while True:\n            print(\'before self.fd_in.read(1)\')\n            char = self.fd_in.read(1)\n            print(\'after self.fd_in.read(1)\', char)\n            buffer.append(char)\n            self.debug(char)\n            if char == \'\\n\':\n                break\n\n        return \'\'.join(buffer)\n\n    def receivepickle(self):\n        msg = json.loads(self._readline())\n        if msg[\'cmd\'] == \'canvasevent\':\n            self.canvas.append(msg)\n        else:\n            self.messages.append(msg)\n\n    def receivemsg(self):\n        while not self.messages:\n            self.receivepickle()\n        return self.messages.pop()\n\n    def receivecanvas(self):\n        while not self.canvas:\n            self.receivepickle()\n        return self.canvas.pop(0)\n\nclass WebCanvas:\n    def __init__(self):\n        self.comm = WebCommunication()\n        self.bindings = {}\n        self.batch = []\n        self.items = []\n\n    def addbatch(self, msg, *params):\n        self.batch.append([msg,params])\n\n    def flushbatch(self):\n        if not self.batch:\n            return\n        self.comm.sendpickle({\'cmd\':\'turtlebatch\',\n                               \'batch\':self.batch})\n        self.batch = []\n\n    # Locally implemented\n    def after(self, delay):\n        time.sleep(delay\/1000)\n\n    def tag_bind(self, item, event, function, add):\n        self.bindings[event] = function\n\n    def tag_unbind(self, event):\n        del self.bindings[event]\n\n    def canvasx(self, x):\n        return x\n\n    def canvasy(self, y):\n        return y\n\n    # batched\n    def create_image(self, w, h, image):\n        self.items.append({\'type\':\'image\',\'image\':image})\n        self.addbatch(\'create_image\', image)\n        return len(self.items)-1\n\n    def create_line(self):\n        self.items.append({\'type\':\'line\',\n                           \'fill\': \'\',\n                           \'coords\':[0,0,0,0],\n                           \'width\':2,\n                           \'capstyle\':\'round\'})\n        self.addbatch(\'create_line\')\n        return len(self.items)-1\n\n    def create_polygon(self):\n        self.items.append({\'type\':\'polygon\',\n                           \'coords\':[0,0,0,0,0,0]\n                           })\n        self.addbatch(\'create_polygon\')\n        return len(self.items)-1\n\n    def coords(self, item, coords=None):\n        if coords is None:\n            return self.items[item][\'coords\']\n        self.items[item][\'coords\'] = coords\n        self.addbatch(\'coords\', item, coords)\n\n    def itemconfigure(self, item, **args):\n        assert len(args) == 1\n        key, value = list(args.items())[0]\n        self.items[item][key] = value\n        self.addbatch(\'itemconfigure\', item, key, value)\n\n    def update(self):\n        self.addbatch(\'update\')\n        self.flushbatch()\n\n    # XXX TODO\n    def tag_raise(self, item):\n        pass\n\n    def __getattr__(self, attr):\n        def call(*args):\n            self.flushbatch()\n            self.comm.sendpickle({\'cmd\':\'turtle\',\n                                   \'action\':attr,\n                                   \'args\':args})\n            result = self.comm.receivemsg()\n            if result[\'cmd\'] == \'result\':\n                return result.get(\'result\') # might be None as JSON leaves out undefined values\n            else:\n                raise getattr(builtins, result[\'exception\'])(result[\'message\'])\n        return call\n\n    def getevent(self):\n        msg = self.comm.receivecanvas()\n        event = Event(msg)\n        if event.type in self.bindings:\n            self.bindings[event.type](event)\n\n\nclass TurtleScreenBase(object):\n    \"\"\"Provide the basic graphics functionality.\n       Interface between Tkinter and turtle.py.\n       To port turtle.py to some different graphics toolkit\n       a corresponding TurtleScreenBase class has to be implemented.\n    \"\"\"\n\n    @staticmethod\n    def _blankimage():\n        \"\"\"return a blank image object\n        \"\"\"\n        return BlankImage()\n\n    @staticmethod\n    def _image(filename):\n        \"\"\"return an image object containing the\n        imagedata from a gif-file named filename.\n        \"\"\"\n        raise IOError(\"opening files is not permitted in this implementation\")\n\n    def __init__(self, cv):\n        self.cv = cv\n        self.canvwidth = cv.get_width()\n        self.canvheight = cv.get_height()\n        self.xscale = self.yscale = 1.0\n\n    def _createpoly(self):\n        \"\"\"Create an invisible polygon item on canvas self.cv)\n        \"\"\"\n        return self.cv.create_polygon()\n\n    def _drawpoly(self, polyitem, coordlist, fill=None,\n                  outline=None, width=None, top=False):\n        \"\"\"Configure polygonitem polyitem according to provided\n        arguments:\n        coordlist is sequence of coordinates\n        fill is filling color\n        outline is outline color\n        top is a boolean value, which specifies if polyitem\n        will be put on top of the canvas\' displaylist so it\n        will not be covered by other items.\n        \"\"\"\n        cl = []\n        for x, y in coordlist:\n            cl.append(x * self.xscale)\n            cl.append(-y * self.yscale)\n        self.cv.coords(polyitem, cl)\n        if fill is not None:\n            self.cv.itemconfigure(polyitem, fill=fill)\n        if outline is not None:\n            self.cv.itemconfigure(polyitem, outline=outline)\n        if width is not None:\n            self.cv.itemconfigure(polyitem, width=width)\n        if top:\n            self.cv.tag_raise(polyitem)\n\n    def _createline(self):\n        \"\"\"Create an invisible line item on canvas self.cv)\n        \"\"\"\n        return self.cv.create_line()\n\n    def _drawline(self, lineitem, coordlist=None,\n                  fill=None, width=None, top=False):\n        \"\"\"Configure lineitem according to provided arguments:\n        coordlist is sequence of coordinates\n        fill is drawing color\n        width is width of drawn line.\n        top is a boolean value, which specifies if polyitem\n        will be put on top of the canvas\' displaylist so it\n        will not be covered by other items.\n        \"\"\"\n        if coordlist is not None:\n            cl = []\n            for x, y in coordlist:\n                cl.append(x * self.xscale)\n                cl.append(-y * self.yscale)\n            self.cv.coords(lineitem, cl)\n        if fill is not None:\n            self.cv.itemconfigure(lineitem, fill=fill)\n        if width is not None:\n            self.cv.itemconfigure(lineitem, width=width)\n        if top:\n            self.cv.tag_raise(lineitem)\n\n    def _delete(self, item):\n        \"\"\"Delete graphics item from canvas.\n        If item is\"all\" delete all graphics items.\n        \"\"\"\n        self.cv.delete(item)\n\n    def _update(self):\n        \"\"\"Redraw graphics items on canvas\n        \"\"\"\n        self.cv.update()\n\n    def _delay(self, delay):\n        \"\"\"Delay subsequent canvas actions for delay ms.\"\"\"\n        self.cv.after(delay)\n\n    def _iscolorstring(self, color):\n        \"\"\"Check if the string color is a legal Tkinter color string.\n        \"\"\"\n        if color[0] == \'#\' and len(color) % 3 == 1:\n            try:\n                int(color[1:], 16)\n            except ValueError:\n                return False\n            return True\n        return color in namedcolors\n\n    def _bgcolor(self, color=None):\n        \"\"\"Set canvas\' backgroundcolor if color is not None,\n        else return backgroundcolor.\"\"\"\n        if color is not None:\n            self.cv.css(\'background-color\', color)\n            self._update()\n        else:\n            return self.cv.css(\'background-color\')\n\n    def _write(self, pos, txt, align, font, pencolor):\n        \"\"\"Write txt at pos in canvas with specified font\n        and color.\n        Return text item and x-coord of right bottom corner\n        of text\'s bounding box.\"\"\"\n        x, y = pos\n        x = x * self.xscale\n        y = y * self.yscale\n        anchor = {\"left\":\"sw\", \"center\":\"s\", \"right\":\"se\" }\n        item = self.cv.create_text(x-1, -y, text = txt, anchor = anchor[align],\n                                        fill = pencolor, font = font)\n        x0, y0, x1, y1 = self.cv.bbox(item)\n        self.cv.update()\n        return item, x1-1\n\n##    def _dot(self, pos, size, color):\n##        \"\"\"may be implemented for some other graphics toolkit\"\"\"\n\n    def _onclick(self, item, fun, num=1, add=None):\n        \"\"\"Bind fun to mouse-click event on turtle.\n        fun must be a function with two arguments, the coordinates\n        of the clicked point on the canvas.\n        num, the number of the mouse-button defaults to 1\n        \"\"\"\n        if fun is None:\n            self.cv.tag_unbind(item, \"<Button-%s>\" % num)\n        else:\n            def eventfun(event):\n                x, y = (self.cv.canvasx(event.x)\/self.xscale,\n                        -self.cv.canvasy(event.y)\/self.yscale)\n                fun(x, y)\n            self.cv.tag_bind(item, \"<Button-%s>\" % num, eventfun, add)\n\n    def _onrelease(self, item, fun, num=1, add=None):\n        \"\"\"Bind fun to mouse-button-release event on turtle.\n        fun must be a function with two arguments, the coordinates\n        of the point on the canvas where mouse button is released.\n        num, the number of the mouse-button defaults to 1\n        If a turtle is clicked, first _onclick-event will be performed,\n        then _onscreensclick-event.\n        \"\"\"\n        if fun is None:\n            self.cv.tag_unbind(item, \"<Button%s-ButtonRelease>\" % num)\n        else:\n            def eventfun(event):\n                x, y = (self.cv.canvasx(event.x)\/self.xscale,\n                        -self.cv.canvasy(event.y)\/self.yscale)\n                fun(x, y)\n            self.cv.tag_bind(item, \"<Button%s-ButtonRelease>\" % num,\n                             eventfun, add)\n\n    def _ondrag(self, item, fun, num=1, add=None):\n        \"\"\"Bind fun to mouse-move-event (with pressed mouse button) on turtle.\n        fun must be a function with two arguments, the coordinates of the\n        actual mouse position on the canvas.\n        num, the number of the mouse-button defaults to 1\n        Every sequence of mouse-move-events on a turtle is preceded by a\n        mouse-click event on that turtle.\n        \"\"\"\n        if fun is None:\n            self.cv.tag_unbind(item, \"<Button%s-Motion>\" % num)\n        else:\n            def eventfun(event):\n                try:\n                    x, y = (self.cv.canvasx(event.x)\/self.xscale,\n                           -self.cv.canvasy(event.y)\/self.yscale)\n                    fun(x, y)\n                except:\n                    pass\n            self.cv.tag_bind(item, \"<Button%s-Motion>\" % num, eventfun, add)\n\n    def _onscreenclick(self, fun, num=1, add=None):\n        \"\"\"Bind fun to mouse-click event on canvas.\n        fun must be a function with two arguments, the coordinates\n        of the clicked point on the canvas.\n        num, the number of the mouse-button defaults to 1\n        If a turtle is clicked, first _onclick-event will be performed,\n        then _onscreensclick-event.\n        \"\"\"\n        # XXX TODO\n        return\n        if fun is None:\n            self.cv.unbind(\"<Button-%s>\" % num)\n        else:\n            def eventfun(event):\n                x, y = (self.cv.canvasx(event.x)\/self.xscale,\n                        -self.cv.canvasy(event.y)\/self.yscale)\n                fun(x, y)\n            self.cv.bind(\"<Button-%s>\" % num, eventfun, add)\n\n    def _onkeyrelease(self, fun, key):\n        \"\"\"Bind fun to key-release event of key.\n        Canvas must have focus. See method listen\n        \"\"\"\n        # XXX TODO\n        return\n        if fun is None:\n            self.cv.unbind(\"<KeyRelease-%s>\" % key, None)\n        else:\n            def eventfun(event):\n                fun()\n            self.cv.bind(\"<KeyRelease-%s>\" % key, eventfun)\n\n    def _onkeypress(self, fun, key=None):\n        \"\"\"If key is given, bind fun to key-press event of key.\n        Otherwise bind fun to any key-press.\n        Canvas must have focus. See method listen.\n        \"\"\"\n        # XXX TODO\n        return\n        if fun is None:\n            if key is None:\n                self.cv.unbind(\"<KeyPress>\", None)\n            else:\n                self.cv.unbind(\"<KeyPress-%s>\" % key, None)\n        else:\n            def eventfun(event):\n                fun()\n            if key is None:\n                self.cv.bind(\"<KeyPress>\", eventfun)\n            else:\n                self.cv.bind(\"<KeyPress-%s>\" % key, eventfun)\n\n    def _listen(self):\n        \"\"\"Set focus on canvas (in order to collect key-events)\n        \"\"\"\n        self.cv.focus_force()\n\n    def _ontimer(self, fun, t):\n        \"\"\"Install a timer, which calls fun after t milliseconds.\n        \"\"\"\n        if t == 0:\n            self.cv.after_idle(fun)\n        else:\n            self.cv.after(t, fun)\n\n    def _createimage(self, image):\n        \"\"\"Create and return image item on canvas.\n        \"\"\"\n        return self.cv.create_image(0, 0, image)\n\n    def _drawimage(self, item, pos, image):\n        \"\"\"Configure image item as to draw image object\n        at position (x,y) on canvas)\n        \"\"\"\n        x, y = pos\n        self.cv.coords(item, (x * self.xscale, -y * self.yscale))\n        self.cv.itemconfig(item, image=image)\n\n    def _setbgpic(self, item, image):\n        \"\"\"Configure image item as to draw image object\n        at center of canvas. Set item to the first item\n        in the displaylist, so it will be drawn below\n        any other item .\"\"\"\n        self.cv.itemconfig(item, image=image)\n        self.cv.tag_lower(item)\n\n    def _type(self, item):\n        \"\"\"Return \'line\' or \'polygon\' or \'image\' depending on\n        type of item.\n        \"\"\"\n        return self.cv.type(item)\n\n    def _pointlist(self, item):\n        \"\"\"returns list of coordinate-pairs of points of item\n        Example (for insiders):\n        >>> from turtle import *\n        >>> getscreen()._pointlist(getturtle().turtle._item)\n        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),\n        (9.9999999999999982, 0.0)]\n        >>> \"\"\"\n        cl = self.cv.coords(item)\n        pl = [(cl[i], -cl[i+1]) for i in range(0, len(cl), 2)]\n        return  pl\n\n    def _setscrollregion(self, srx1, sry1, srx2, sry2):\n        self.cv.config(scrollregion=(srx1, sry1, srx2, sry2))\n\n    def _rescale(self, xscalefactor, yscalefactor):\n        items = self.cv.find_all()\n        for item in items:\n            coordinates = list(self.cv.coords(item))\n            newcoordlist = []\n            while coordinates:\n                x, y = coordinates[:2]\n                newcoordlist.append(x * xscalefactor)\n                newcoordlist.append(y * yscalefactor)\n                coordinates = coordinates[2:]\n            self.cv.coords(item, newcoordlist)\n\n    def _resize(self, canvwidth=None, canvheight=None, bg=None):\n        \"\"\"Resize the canvas the turtles are drawing on. Does\n        not alter the drawing window.\n        \"\"\"\n        # needs amendment\n        if not isinstance(self.cv, ScrolledCanvas):\n            return self.canvwidth, self.canvheight\n        if canvwidth is canvheight is bg is None:\n            return self.cv.canvwidth, self.cv.canvheight\n        if canvwidth is not None:\n            self.canvwidth = canvwidth\n        if canvheight is not None:\n            self.canvheight = canvheight\n        self.cv.reset(canvwidth, canvheight, bg)\n\n    def _window_size(self):\n        \"\"\" Return the width and height of the turtle window.\n        \"\"\"\n        width = self.cv.winfo_width()\n        if width <= 1:  # the window isn\'t managed by a geometry manager\n            width = self.cv[\'width\']\n        height = self.cv.winfo_height()\n        if height <= 1: # the window isn\'t managed by a geometry manager\n            height = self.cv[\'height\']\n        return width, height\n\n    def mainloop(self):\n        \"\"\"Starts event loop - calling Tkinter\'s mainloop function.\n        No argument.\n        Must be last statement in a turtle graphics program.\n        Must NOT be used if a script is run from within IDLE in -n mode\n        (No subprocess) - for interactive use of turtle graphics.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.mainloop()\n        \"\"\"\n        i = 1\n        while True:\n            i = i+1\n            self.cv.getevent()\n\n\n    def textinput(self, title, prompt):\n        \"\"\"Pop up a dialog window for input of a string.\n        Arguments: title is the title of the dialog window,\n        prompt is a text mostly describing what information to input.\n        Return the string input\n        If the dialog is canceled, return None.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.textinput(\"NIM\", \"Name of first player:\")\n        \"\"\"\n        # XXX TODO\n        return simpledialog.askstring(title, prompt)\n\n    def numinput(self, title, prompt, default=None, minval=None, maxval=None):\n        \"\"\"Pop up a dialog window for input of a number.\n        Arguments: title is the title of the dialog window,\n        prompt is a text mostly describing what numerical information to input.\n        default: default value\n        minval: minimum value for imput\n        maxval: maximum value for input\n        The number input must be in the range minval .. maxval if these are\n        given. If not, a hint is issued and the dialog remains open for\n        correction. Return the number input.\n        If the dialog is canceled,  return None.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.numinput(\"Poker\", \"Your stakes:\", 1000, minval=10, maxval=10000)\n        \"\"\"\n        return simpledialog.askfloat(title, prompt, initialvalue=default,\n                                     minvalue=minval, maxvalue=maxval)\n\n\n##############################################################################\n###                  End of Tkinter - interface                            ###\n##############################################################################\n\n\nclass Terminator (Exception):\n    \"\"\"Will be raised in TurtleScreen.update, if _RUNNING becomes False.\n    This stops execution of a turtle graphics script.\n    Main purpose: use in the Demo-Viewer turtle.Demo.py.\n    \"\"\"\n    pass\n\n\nclass TurtleGraphicsError(Exception):\n    \"\"\"Some TurtleGraphics Error\n    \"\"\"\n\n\nclass Shape(object):\n    \"\"\"Data structure modeling shapes.\n    attribute _type is one of \"polygon\", \"image\", \"compound\"\n    attribute _data is - depending on _type a poygon-tuple,\n    an image or a list constructed using the addcomponent method.\n    \"\"\"\n    def __init__(self, type_, data=None):\n        self._type = type_\n        if type_ == \"polygon\":\n            if isinstance(data, list):\n                data = tuple(data)\n        elif type_ == \"image\":\n            if isinstance(data, str):\n                if data.lower().endswith(\".gif\") and isfile(data):\n                    data = TurtleScreen._image(data)\n                # else data assumed to be Photoimage\n        elif type_ == \"compound\":\n            data = []\n        else:\n            raise TurtleGraphicsError(\"There is no shape type %s\" % type_)\n        self._data = data\n\n    def addcomponent(self, poly, fill, outline=None):\n        \"\"\"Add component to a shape of type compound.\n        Arguments: poly is a polygon, i. e. a tuple of number pairs.\n        fill is the fillcolor of the component,\n        outline is the outline color of the component.\n        call (for a Shapeobject namend s):\n        --   s.addcomponent(((0,0), (10,10), (-10,10)), \"red\", \"blue\")\n        Example:\n        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))\n        >>> s = Shape(\"compound\")\n        >>> s.addcomponent(poly, \"red\", \"blue\")\n        >>> # .. add more components and then use register_shape()\n        \"\"\"\n        if self._type != \"compound\":\n            raise TurtleGraphicsError(\"Cannot add component to %s Shape\"\n                                                                % self._type)\n        if outline is None:\n            outline = fill\n        self._data.append([poly, fill, outline])\n\n\nclass Tbuffer(object):\n    \"\"\"Ring buffer used as undobuffer for RawTurtle objects.\"\"\"\n    def __init__(self, bufsize=10):\n        self.bufsize = bufsize\n        self.buffer = [[None]] * bufsize\n        self.ptr = -1\n        self.cumulate = False\n    def reset(self, bufsize=None):\n        if bufsize is None:\n            for i in range(self.bufsize):\n                self.buffer[i] = [None]\n        else:\n            self.bufsize = bufsize\n            self.buffer = [[None]] * bufsize\n        self.ptr = -1\n    def push(self, item):\n        if self.bufsize > 0:\n            if not self.cumulate:\n                self.ptr = (self.ptr + 1) % self.bufsize\n                self.buffer[self.ptr] = item\n            else:\n                self.buffer[self.ptr].append(item)\n    def pop(self):\n        if self.bufsize > 0:\n            item = self.buffer[self.ptr]\n            if item is None:\n                return None\n            else:\n                self.buffer[self.ptr] = [None]\n                self.ptr = (self.ptr - 1) % self.bufsize\n                return (item)\n    def nr_of_items(self):\n        return self.bufsize - self.buffer.count([None])\n    def __repr__(self):\n        return str(self.buffer) + \" \" + str(self.ptr)\n\n\n\nclass TurtleScreen(TurtleScreenBase):\n    \"\"\"Provides screen oriented methods like setbg etc.\n    Only relies upon the methods of TurtleScreenBase and NOT\n    upon components of the underlying graphics toolkit -\n    which is Tkinter in this case.\n    \"\"\"\n    _RUNNING = True\n\n    def __init__(self, cv, mode=_CFG[\"mode\"],\n                 colormode=_CFG[\"colormode\"], delay=_CFG[\"delay\"]):\n        self._shapes = {\n                   \"arrow\" : Shape(\"polygon\", ((-10,0), (10,0), (0,10))),\n                  \"turtle\" : Shape(\"polygon\", ((0,16), (-2,14), (-1,10), (-4,7),\n                              (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),\n                              (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),\n                              (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),\n                              (2,14))),\n                  \"circle\" : Shape(\"polygon\", ((10,0), (9.51,3.09), (8.09,5.88),\n                              (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),\n                              (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),\n                              (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),\n                              (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),\n                              (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),\n                  \"square\" : Shape(\"polygon\", ((10,-10), (10,10), (-10,10),\n                              (-10,-10))),\n                \"triangle\" : Shape(\"polygon\", ((10,-5.77), (0,11.55),\n                              (-10,-5.77))),\n                  \"classic\": Shape(\"polygon\", ((0,0),(-5,-9),(0,-7),(5,-9))),\n                   \"blank\" : Shape(\"image\", self._blankimage())\n                  }\n\n        self._bgpics = {\"nopic\" : \"\"}\n\n        TurtleScreenBase.__init__(self, cv)\n        self._mode = mode\n        self._delayvalue = delay\n        self._colormode = _CFG[\"colormode\"]\n        self._keys = []\n        self.clear()\n        if 0 and sys.platform == \'darwin\': # disabled for webpython\n            # Force Turtle window to the front on OS X. This is needed because\n            # the Turtle window will show behind the Terminal window when you\n            # start the demo from the command line.\n            cv._rootwindow.call(\'wm\', \'attributes\', \'.\', \'-topmost\', \'1\')\n            cv._rootwindow.call(\'wm\', \'attributes\', \'.\', \'-topmost\', \'0\')\n\n    def clear(self):\n        \"\"\"Delete all drawings and all turtles from the TurtleScreen.\n        No argument.\n        Reset empty TurtleScreen to its initial state: white background,\n        no backgroundimage, no eventbindings and tracing on.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.clear()\n        Note: this method is not available as function.\n        \"\"\"\n        self._delayvalue = _CFG[\"delay\"]\n        self._colormode = _CFG[\"colormode\"]\n        self._delete(\"all\")\n        self._bgpic = self._createimage(\"\")\n        self._bgpicname = \"nopic\"\n        self._tracing = 1\n        self._updatecounter = 0\n        self._turtles = []\n        self.bgcolor(\"white\")\n        for btn in 1, 2, 3:\n            self.onclick(None, btn)\n        self.onkeypress(None)\n        for key in self._keys[:]:\n            self.onkey(None, key)\n            self.onkeypress(None, key)\n        Turtle._pen = None\n\n    def mode(self, mode=None):\n        \"\"\"Set turtle-mode (\'standard\', \'logo\' or \'world\') and perform reset.\n        Optional argument:\n        mode -- on of the strings \'standard\', \'logo\' or \'world\'\n        Mode \'standard\' is compatible with turtle.py.\n        Mode \'logo\' is compatible with most Logo-Turtle-Graphics.\n        Mode \'world\' uses userdefined \'worldcoordinates\'. *Attention*: in\n        this mode angles appear distorted if x\/y unit-ratio doesn\'t equal 1.\n        If mode is not given, return the current mode.\n             Mode      Initial turtle heading     positive angles\n         ------------|-------------------------|-------------------\n          \'standard\'    to the right (east)       counterclockwise\n            \'logo\'        upward    (north)         clockwise\n        Examples:\n        >>> mode(\'logo\')   # resets turtle heading to north\n        >>> mode()\n        \'logo\'\n        \"\"\"\n        if mode is None:\n            return self._mode\n        mode = mode.lower()\n        if mode not in [\"standard\", \"logo\", \"world\"]:\n            raise TurtleGraphicsError(\"No turtle-graphics-mode %s\" % mode)\n        self._mode = mode\n        if mode in [\"standard\", \"logo\"]:\n            self._setscrollregion(-self.canvwidth\/\/2, -self.canvheight\/\/2,\n                                       self.canvwidth\/\/2, self.canvheight\/\/2)\n            self.xscale = self.yscale = 1.0\n        self.reset()\n\n    def setworldcoordinates(self, llx, lly, urx, ury):\n        \"\"\"Set up a user defined coordinate-system.\n        Arguments:\n        llx -- a number, x-coordinate of lower left corner of canvas\n        lly -- a number, y-coordinate of lower left corner of canvas\n        urx -- a number, x-coordinate of upper right corner of canvas\n        ury -- a number, y-coordinate of upper right corner of canvas\n        Set up user coodinat-system and switch to mode \'world\' if necessary.\n        This performs a screen.reset. If mode \'world\' is already active,\n        all drawings are redrawn according to the new coordinates.\n        But ATTENTION: in user-defined coordinatesystems angles may appear\n        distorted. (see Screen.mode())\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.setworldcoordinates(-10,-0.5,50,1.5)\n        >>> for _ in range(36):\n        ...     left(10)\n        ...     forward(0.5)\n        \"\"\"\n        if self.mode() != \"world\":\n            self.mode(\"world\")\n        xspan = float(urx - llx)\n        yspan = float(ury - lly)\n        wx, wy = self._window_size()\n        self.screensize(wx-20, wy-20)\n        oldxscale, oldyscale = self.xscale, self.yscale\n        self.xscale = self.canvwidth \/ xspan\n        self.yscale = self.canvheight \/ yspan\n        srx1 = llx * self.xscale\n        sry1 = -ury * self.yscale\n        srx2 = self.canvwidth + srx1\n        sry2 = self.canvheight + sry1\n        self._setscrollregion(srx1, sry1, srx2, sry2)\n        self._rescale(self.xscale\/oldxscale, self.yscale\/oldyscale)\n        self.update()\n\n    def register_shape(self, name, shape=None):\n        \"\"\"Adds a turtle shape to TurtleScreen\'s shapelist.\n        Arguments:\n        (1) name is the name of a gif-file and shape is None.\n            Installs the corresponding image shape.\n            !! Image-shapes DO NOT rotate when turning the turtle,\n            !! so they do not display the heading of the turtle!\n        (2) name is an arbitrary string and shape is a tuple\n            of pairs of coordinates. Installs the corresponding\n            polygon shape\n        (3) name is an arbitrary string and shape is a\n            (compound) Shape object. Installs the corresponding\n            compound shape.\n        To use a shape, you have to issue the command shape(shapename).\n        call: register_shape(\"turtle.gif\")\n        --or: register_shape(\"tri\", ((0,0), (10,10), (-10,10)))\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.register_shape(\"triangle\", ((5,-3),(0,5),(-5,-3)))\n        \"\"\"\n        if shape is None:\n            # image\n            if name.lower().endswith(\".gif\"):\n                shape = Shape(\"image\", self._image(name))\n            else:\n                raise TurtleGraphicsError(\"Bad arguments for register_shape.\\n\"\n                                          + \"Use  help(register_shape)\" )\n        elif isinstance(shape, tuple):\n            shape = Shape(\"polygon\", shape)\n        ## else shape assumed to be Shape-instance\n        self._shapes[name] = shape\n\n    def _colorstr(self, color):\n        \"\"\"Return color string corresponding to args.\n        Argument may be a string or a tuple of three\n        numbers corresponding to actual colormode,\n        i.e. in the range 0<=n<=colormode.\n        If the argument doesn\'t represent a color,\n        an error is raised.\n        \"\"\"\n        if len(color) == 1:\n            color = color[0]\n        if isinstance(color, str):\n            if self._iscolorstring(color) or color == \"\":\n                return color\n            else:\n                raise TurtleGraphicsError(\"bad color string: %s\" % str(color))\n        try:\n            r, g, b = color\n        except:\n            raise TurtleGraphicsError(\"bad color arguments: %s\" % str(color))\n        if self._colormode == 1.0:\n            r, g, b = [round(255.0*x) for x in (r, g, b)]\n        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):\n            raise TurtleGraphicsError(\"bad color sequence: %s\" % str(color))\n        return \"#%02x%02x%02x\" % (r, g, b)\n\n    def _color(self, cstr):\n        if not cstr.startswith(\"#\"):\n            return cstr\n        if len(cstr) == 7:\n            cl = [int(cstr[i:i+2], 16) for i in (1, 3, 5)]\n        elif len(cstr) == 4:\n            cl = [16*int(cstr[h], 16) for h in cstr[1:]]\n        else:\n            raise TurtleGraphicsError(\"bad colorstring: %s\" % cstr)\n        return tuple([c * self._colormode\/255 for c in cl])\n\n    def colormode(self, cmode=None):\n        \"\"\"Return the colormode or set it to 1.0 or 255.\n        Optional argument:\n        cmode -- one of the values 1.0 or 255\n        r, g, b values of colortriples have to be in range 0..cmode.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.colormode()\n        1.0\n        >>> screen.colormode(255)\n        >>> pencolor(240,160,80)\n        \"\"\"\n        if cmode is None:\n            return self._colormode\n        if cmode == 1.0:\n            self._colormode = float(cmode)\n        elif cmode == 255:\n            self._colormode = int(cmode)\n\n    def reset(self):\n        \"\"\"Reset all Turtles on the Screen to their initial state.\n        No argument.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.reset()\n        \"\"\"\n        for turtle in self._turtles:\n            turtle._setmode(self._mode)\n            turtle.reset()\n\n    def turtles(self):\n        \"\"\"Return the list of turtles on the screen.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.turtles()\n        [<turtle.Turtle object at 0x00E11FB0>]\n        \"\"\"\n        return self._turtles\n\n    def bgcolor(self, *args):\n        \"\"\"Set or return backgroundcolor of the TurtleScreen.\n        Arguments (if given): a color string or three numbers\n        in the range 0..colormode or a 3-tuple of such numbers.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.bgcolor(\"orange\")\n        >>> screen.bgcolor()\n        \'orange\'\n        >>> screen.bgcolor(0.5,0,0.5)\n        >>> screen.bgcolor()\n        \'#800080\'\n        \"\"\"\n        if args:\n            color = self._colorstr(args)\n        else:\n            color = None\n        color = self._bgcolor(color)\n        if color is not None:\n            color = self._color(color)\n        return color\n\n    def tracer(self, n=None, delay=None):\n        \"\"\"Turns turtle animation on\/off and set delay for update drawings.\n        Optional arguments:\n        n -- nonnegative  integer\n        delay -- nonnegative  integer\n        If n is given, only each n-th regular screen update is really performed.\n        (Can be used to accelerate the drawing of complex graphics.)\n        Second arguments sets delay value (see RawTurtle.delay())\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.tracer(8, 25)\n        >>> dist = 2\n        >>> for i in range(200):\n        ...     fd(dist)\n        ...     rt(90)\n        ...     dist += 2\n        \"\"\"\n        if n is None:\n            return self._tracing\n        self._tracing = int(n)\n        self._updatecounter = 0\n        if delay is not None:\n            self._delayvalue = int(delay)\n        if self._tracing:\n            self.update()\n\n    def delay(self, delay=None):\n        \"\"\" Return or set the drawing delay in milliseconds.\n        Optional argument:\n        delay -- positive integer\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.delay(15)\n        >>> screen.delay()\n        15\n        \"\"\"\n        if delay is None:\n            return self._delayvalue\n        self._delayvalue = int(delay)\n\n    def _incrementudc(self):\n        \"\"\"Increment update counter.\"\"\"\n        if not TurtleScreen._RUNNING:\n            TurtleScreen._RUNNNING = True\n            raise Terminator\n        if self._tracing > 0:\n            self._updatecounter += 1\n            self._updatecounter %= self._tracing\n\n    def update(self):\n        \"\"\"Perform a TurtleScreen update.\n        \"\"\"\n        tracing = self._tracing\n        self._tracing = True\n        for t in self.turtles():\n            t._update_data()\n            t._drawturtle()\n        self._tracing = tracing\n        self._update()\n\n    def window_width(self):\n        \"\"\" Return the width of the turtle window.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.window_width()\n        640\n        \"\"\"\n        return self._window_size()[0]\n\n    def window_height(self):\n        \"\"\" Return the height of the turtle window.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.window_height()\n        480\n        \"\"\"\n        return self._window_size()[1]\n\n    def getcanvas(self):\n        \"\"\"Return the Canvas of this TurtleScreen.\n        No argument.\n        Example (for a Screen instance named screen):\n        >>> cv = screen.getcanvas()\n        >>> cv\n        <turtle.ScrolledCanvas instance at 0x010742D8>\n        \"\"\"\n        return self.cv\n\n    def getshapes(self):\n        \"\"\"Return a list of names of all currently available turtle shapes.\n        No argument.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.getshapes()\n        [\'arrow\', \'blank\', \'circle\', ... , \'turtle\']\n        \"\"\"\n        return sorted(self._shapes.keys())\n\n    def onclick(self, fun, btn=1, add=None):\n        \"\"\"Bind fun to mouse-click event on canvas.\n        Arguments:\n        fun -- a function with two arguments, the coordinates of the\n               clicked point on the canvas.\n        num -- the number of the mouse-button, defaults to 1\n        Example (for a TurtleScreen instance named screen)\n        >>> screen.onclick(goto)\n        >>> # Subsequently clicking into the TurtleScreen will\n        >>> # make the turtle move to the clicked point.\n        >>> screen.onclick(None)\n        \"\"\"\n        self._onscreenclick(fun, btn, add)\n\n    def onkey(self, fun, key):\n        \"\"\"Bind fun to key-release event of key.\n        Arguments:\n        fun -- a function with no arguments\n        key -- a string: key (e.g. \"a\") or key-symbol (e.g. \"space\")\n        In order to be able to register key-events, TurtleScreen\n        must have focus. (See method listen.)\n        Example (for a TurtleScreen instance named screen):\n        >>> def f():\n        ...     fd(50)\n        ...     lt(60)\n        ...\n        >>> screen.onkey(f, \"Up\")\n        >>> screen.listen()\n        Subsequently the turtle can be moved by repeatedly pressing\n        the up-arrow key, consequently drawing a hexagon\n        \"\"\"\n        if fun is None:\n            if key in self._keys:\n                self._keys.remove(key)\n        elif key not in self._keys:\n            self._keys.append(key)\n        self._onkeyrelease(fun, key)\n\n    def onkeypress(self, fun, key=None):\n        \"\"\"Bind fun to key-press event of key if key is given,\n        or to any key-press-event if no key is given.\n        Arguments:\n        fun -- a function with no arguments\n        key -- a string: key (e.g. \"a\") or key-symbol (e.g. \"space\")\n        In order to be able to register key-events, TurtleScreen\n        must have focus. (See method listen.)\n        Example (for a TurtleScreen instance named screen\n        and a Turtle instance named turtle):\n        >>> def f():\n        ...     fd(50)\n        ...     lt(60)\n        ...\n        >>> screen.onkeypress(f, \"Up\")\n        >>> screen.listen()\n        Subsequently the turtle can be moved by repeatedly pressing\n        the up-arrow key, or by keeping pressed the up-arrow key.\n        consequently drawing a hexagon.\n        \"\"\"\n        if fun is None:\n            if key in self._keys:\n                self._keys.remove(key)\n        elif key is not None and key not in self._keys:\n            self._keys.append(key)\n        self._onkeypress(fun, key)\n\n    def listen(self, xdummy=None, ydummy=None):\n        \"\"\"Set focus on TurtleScreen (in order to collect key-events)\n        No arguments.\n        Dummy arguments are provided in order\n        to be able to pass listen to the onclick method.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.listen()\n        \"\"\"\n        self._listen()\n\n    def ontimer(self, fun, t=0):\n        \"\"\"Install a timer, which calls fun after t milliseconds.\n        Arguments:\n        fun -- a function with no arguments.\n        t -- a number >= 0\n        Example (for a TurtleScreen instance named screen):\n        >>> running = True\n        >>> def f():\n        ...     if running:\n        ...             fd(50)\n        ...             lt(60)\n        ...             screen.ontimer(f, 250)\n        ...\n        >>> f()   # makes the turtle marching around\n        >>> running = False\n        \"\"\"\n        self._ontimer(fun, t)\n\n    def bgpic(self, picname=None):\n        \"\"\"Set background image or return name of current backgroundimage.\n        Optional argument:\n        picname -- a string, name of a gif-file or \"nopic\".\n        If picname is a filename, set the corresponding image as background.\n        If picname is \"nopic\", delete backgroundimage, if present.\n        If picname is None, return the filename of the current backgroundimage.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.bgpic()\n        \'nopic\'\n        >>> screen.bgpic(\"landscape.gif\")\n        >>> screen.bgpic()\n        \'landscape.gif\'\n        \"\"\"\n        if picname is None:\n            return self._bgpicname\n        if picname not in self._bgpics:\n            self._bgpics[picname] = self._image(picname)\n        self._setbgpic(self._bgpic, self._bgpics[picname])\n        self._bgpicname = picname\n\n    def screensize(self, canvwidth=None, canvheight=None, bg=None):\n        \"\"\"Resize the canvas the turtles are drawing on.\n        Optional arguments:\n        canvwidth -- positive integer, new width of canvas in pixels\n        canvheight --  positive integer, new height of canvas in pixels\n        bg -- colorstring or color-tuple, new backgroundcolor\n        If no arguments are given, return current (canvaswidth, canvasheight)\n        Do not alter the drawing window. To observe hidden parts of\n        the canvas use the scrollbars. (Can make visible those parts\n        of a drawing, which were outside the canvas before!)\n        Example (for a Turtle instance named turtle):\n        >>> turtle.screensize(2000,1500)\n        >>> # e.g. to search for an erroneously escaped turtle ;-)\n        \"\"\"\n        return self._resize(canvwidth, canvheight, bg)\n\n    onscreenclick = onclick\n    resetscreen = reset\n    clearscreen = clear\n    addshape = register_shape\n    onkeyrelease = onkey\n\nclass TNavigator(object):\n    \"\"\"Navigation part of the RawTurtle.\n    Implements methods for turtle movement.\n    \"\"\"\n    START_ORIENTATION = {\n        \"standard\": Vec2D(1.0, 0.0),\n        \"world\"   : Vec2D(1.0, 0.0),\n        \"logo\"    : Vec2D(0.0, 1.0)  }\n    DEFAULT_MODE = \"standard\"\n    DEFAULT_ANGLEOFFSET = 0\n    DEFAULT_ANGLEORIENT = 1\n\n    def __init__(self, mode=DEFAULT_MODE):\n        self._angleOffset = self.DEFAULT_ANGLEOFFSET\n        self._angleOrient = self.DEFAULT_ANGLEORIENT\n        self._mode = mode\n        self.undobuffer = None\n        self.degrees()\n        self._mode = None\n        self._setmode(mode)\n        TNavigator.reset(self)\n\n    def reset(self):\n        \"\"\"reset turtle to its initial values\n        Will be overwritten by parent class\n        \"\"\"\n        self._position = Vec2D(0.0, 0.0)\n        self._orient =  TNavigator.START_ORIENTATION[self._mode]\n\n    def _setmode(self, mode=None):\n        \"\"\"Set turtle-mode to \'standard\', \'world\' or \'logo\'.\n        \"\"\"\n        if mode is None:\n            return self._mode\n        if mode not in [\"standard\", \"logo\", \"world\"]:\n            return\n        self._mode = mode\n        if mode in [\"standard\", \"world\"]:\n            self._angleOffset = 0\n            self._angleOrient = 1\n        else: # mode == \"logo\":\n            self._angleOffset = self._fullcircle\/4.\n            self._angleOrient = -1\n\n    def _setDegreesPerAU(self, fullcircle):\n        \"\"\"Helper function for degrees() and radians()\"\"\"\n        self._fullcircle = fullcircle\n        self._degreesPerAU = 360\/fullcircle\n        if self._mode == \"standard\":\n            self._angleOffset = 0\n        else:\n            self._angleOffset = fullcircle\/4.\n\n    def degrees(self, fullcircle=360.0):\n        \"\"\" Set angle measurement units to degrees.\n        Optional argument:\n        fullcircle -  a number\n        Set angle measurement units, i. e. set number\n        of \'degrees\' for a full circle. Dafault value is\n        360 degrees.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.left(90)\n        >>> turtle.heading()\n        90\n        Change angle measurement unit to grad (also known as gon,\n        grade, or gradian and equals 1\/100-th of the right angle.)\n        >>> turtle.degrees(400.0)\n        >>> turtle.heading()\n        100\n        \"\"\"\n        self._setDegreesPerAU(fullcircle)\n\n    def radians(self):\n        \"\"\" Set the angle measurement units to radians.\n        No arguments.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.heading()\n        90\n        >>> turtle.radians()\n        >>> turtle.heading()\n        1.5707963267948966\n        \"\"\"\n        self._setDegreesPerAU(2*math.pi)\n\n    def _go(self, distance):\n        \"\"\"move turtle forward by specified distance\"\"\"\n        ende = self._position + self._orient * distance\n        self._goto(ende)\n\n    def _rotate(self, angle):\n        \"\"\"Turn turtle counterclockwise by specified angle if angle > 0.\"\"\"\n        angle *= self._degreesPerAU\n        self._orient = self._orient.rotate(angle)\n\n    def _goto(self, end):\n        \"\"\"move turtle to position end.\"\"\"\n        self._position = end\n\n    def forward(self, distance):\n        \"\"\"Move the turtle forward by the specified distance.\n        Aliases: forward | fd\n        Argument:\n        distance -- a number (integer or float)\n        Move the turtle forward by the specified distance, in the direction\n        the turtle is headed.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.position()\n        (0.00, 0.00)\n        >>> turtle.forward(25)\n        >>> turtle.position()\n        (25.00,0.00)\n        >>> turtle.forward(-75)\n        >>> turtle.position()\n        (-50.00,0.00)\n        \"\"\"\n        self._go(distance)\n\n    def back(self, distance):\n        \"\"\"Move the turtle backward by distance.\n        Aliases: back | backward | bk\n        Argument:\n        distance -- a number\n        Move the turtle backward by distance ,opposite to the direction the\n        turtle is headed. Do not change the turtle\'s heading.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.position()\n        (0.00, 0.00)\n        >>> turtle.backward(30)\n        >>> turtle.position()\n        (-30.00, 0.00)\n        \"\"\"\n        self._go(-distance)\n\n    def right(self, angle):\n        \"\"\"Turn turtle right by angle units.\n        Aliases: right | rt\n        Argument:\n        angle -- a number (integer or float)\n        Turn turtle right by angle units. (Units are by default degrees,\n        but can be set via the degrees() and radians() functions.)\n        Angle orientation depends on mode. (See this.)\n        Example (for a Turtle instance named turtle):\n        >>> turtle.heading()\n        22.0\n        >>> turtle.right(45)\n        >>> turtle.heading()\n        337.0\n        \"\"\"\n        self._rotate(-angle)\n\n    def left(self, angle):\n        \"\"\"Turn turtle left by angle units.\n        Aliases: left | lt\n        Argument:\n        angle -- a number (integer or float)\n        Turn turtle left by angle units. (Units are by default degrees,\n        but can be set via the degrees() and radians() functions.)\n        Angle orientation depends on mode. (See this.)\n        Example (for a Turtle instance named turtle):\n        >>> turtle.heading()\n        22.0\n        >>> turtle.left(45)\n        >>> turtle.heading()\n        67.0\n        \"\"\"\n        self._rotate(angle)\n\n    def pos(self):\n        \"\"\"Return the turtle\'s current location (x,y), as a Vec2D-vector.\n        Aliases: pos | position\n        No arguments.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pos()\n        (0.00, 240.00)\n        \"\"\"\n        return self._position\n\n    def xcor(self):\n        \"\"\" Return the turtle\'s x coordinate.\n        No arguments.\n        Example (for a Turtle instance named turtle):\n        >>> reset()\n        >>> turtle.left(60)\n        >>> turtle.forward(100)\n        >>> print turtle.xcor()\n        50.0\n        \"\"\"\n        return self._position[0]\n\n    def ycor(self):\n        \"\"\" Return the turtle\'s y coordinate\n        ---\n        No arguments.\n        Example (for a Turtle instance named turtle):\n        >>> reset()\n        >>> turtle.left(60)\n        >>> turtle.forward(100)\n        >>> print turtle.ycor()\n        86.6025403784\n        \"\"\"\n        return self._position[1]\n\n\n    def goto(self, x, y=None):\n        \"\"\"Move turtle to an absolute position.\n        Aliases: setpos | setposition | goto:\n        Arguments:\n        x -- a number      or     a pair\/vector of numbers\n        y -- a number             None\n        call: goto(x, y)         # two coordinates\n        --or: goto((x, y))       # a pair (tuple) of coordinates\n        --or: goto(vec)          # e.g. as returned by pos()\n        Move turtle to an absolute position. If the pen is down,\n        a line will be drawn. The turtle\'s orientation does not change.\n        Example (for a Turtle instance named turtle):\n        >>> tp = turtle.pos()\n        >>> tp\n        (0.00, 0.00)\n        >>> turtle.setpos(60,30)\n        >>> turtle.pos()\n        (60.00,30.00)\n        >>> turtle.setpos((20,80))\n        >>> turtle.pos()\n        (20.00,80.00)\n        >>> turtle.setpos(tp)\n        >>> turtle.pos()\n        (0.00,0.00)\n        \"\"\"\n        if y is None:\n            self._goto(Vec2D(*x))\n        else:\n            self._goto(Vec2D(x, y))\n\n    def home(self):\n        \"\"\"Move turtle to the origin - coordinates (0,0).\n        No arguments.\n        Move turtle to the origin - coordinates (0,0) and set its\n        heading to its start-orientation (which depends on mode).\n        Example (for a Turtle instance named turtle):\n        >>> turtle.home()\n        \"\"\"\n        self.goto(0, 0)\n        self.setheading(0)\n\n    def setx(self, x):\n        \"\"\"Set the turtle\'s first coordinate to x\n        Argument:\n        x -- a number (integer or float)\n        Set the turtle\'s first coordinate to x, leave second coordinate\n        unchanged.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.position()\n        (0.00, 240.00)\n        >>> turtle.setx(10)\n        >>> turtle.position()\n        (10.00, 240.00)\n        \"\"\"\n        self._goto(Vec2D(x, self._position[1]))\n\n    def sety(self, y):\n        \"\"\"Set the turtle\'s second coordinate to y\n        Argument:\n        y -- a number (integer or float)\n        Set the turtle\'s first coordinate to x, second coordinate remains\n        unchanged.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.position()\n        (0.00, 40.00)\n        >>> turtle.sety(-10)\n        >>> turtle.position()\n        (0.00, -10.00)\n        \"\"\"\n        self._goto(Vec2D(self._position[0], y))\n\n    def distance(self, x, y=None):\n        \"\"\"Return the distance from the turtle to (x,y) in turtle step units.\n        Arguments:\n        x -- a number   or  a pair\/vector of numbers   or   a turtle instance\n        y -- a number       None                            None\n        call: distance(x, y)         # two coordinates\n        --or: distance((x, y))       # a pair (tuple) of coordinates\n        --or: distance(vec)          # e.g. as returned by pos()\n        --or: distance(mypen)        # where mypen is another turtle\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pos()\n        (0.00, 0.00)\n        >>> turtle.distance(30,40)\n        50.0\n        >>> pen = Turtle()\n        >>> pen.forward(77)\n        >>> turtle.distance(pen)\n        77.0\n        \"\"\"\n        if y is not None:\n            pos = Vec2D(x, y)\n        if isinstance(x, Vec2D):\n            pos = x\n        elif isinstance(x, tuple):\n            pos = Vec2D(*x)\n        elif isinstance(x, TNavigator):\n            pos = x._position\n        return abs(pos - self._position)\n\n    def towards(self, x, y=None):\n        \"\"\"Return the angle of the line from the turtle\'s position to (x, y).\n        Arguments:\n        x -- a number   or  a pair\/vector of numbers   or   a turtle instance\n        y -- a number       None                            None\n        call: distance(x, y)         # two coordinates\n        --or: distance((x, y))       # a pair (tuple) of coordinates\n        --or: distance(vec)          # e.g. as returned by pos()\n        --or: distance(mypen)        # where mypen is another turtle\n        Return the angle, between the line from turtle-position to position\n        specified by x, y and the turtle\'s start orientation. (Depends on\n        modes - \"standard\" or \"logo\")\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pos()\n        (10.00, 10.00)\n        >>> turtle.towards(0,0)\n        225.0\n        \"\"\"\n        if y is not None:\n            pos = Vec2D(x, y)\n        if isinstance(x, Vec2D):\n            pos = x\n        elif isinstance(x, tuple):\n            pos = Vec2D(*x)\n        elif isinstance(x, TNavigator):\n            pos = x._position\n        x, y = pos - self._position\n        result = round(math.atan2(y, x)*180.0\/math.pi, 10) % 360.0\n        result \/= self._degreesPerAU\n        return (self._angleOffset + self._angleOrient*result) % self._fullcircle\n\n    def heading(self):\n        \"\"\" Return the turtle\'s current heading.\n        No arguments.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.left(67)\n        >>> turtle.heading()\n        67.0\n        \"\"\"\n        x, y = self._orient\n        result = round(math.atan2(y, x)*180.0\/math.pi, 10) % 360.0\n        result \/= self._degreesPerAU\n        return (self._angleOffset + self._angleOrient*result) % self._fullcircle\n\n    def setheading(self, to_angle):\n        \"\"\"Set the orientation of the turtle to to_angle.\n        Aliases:  setheading | seth\n        Argument:\n        to_angle -- a number (integer or float)\n        Set the orientation of the turtle to to_angle.\n        Here are some common directions in degrees:\n         standard - mode:          logo-mode:\n        -------------------|--------------------\n           0 - east                0 - north\n          90 - north              90 - east\n         180 - west              180 - south\n         270 - south             270 - west\n        Example (for a Turtle instance named turtle):\n        >>> turtle.setheading(90)\n        >>> turtle.heading()\n        90\n        \"\"\"\n        angle = (to_angle - self.heading())*self._angleOrient\n        full = self._fullcircle\n        angle = (angle+full\/2.)%full - full\/2.\n        self._rotate(angle)\n\n    def circle(self, radius, extent = None, steps = None):\n        \"\"\" Draw a circle with given radius.\n        Arguments:\n        radius -- a number\n        extent (optional) -- a number\n        steps (optional) -- an integer\n        Draw a circle with given radius. The center is radius units left\n        of the turtle; extent - an angle - determines which part of the\n        circle is drawn. If extent is not given, draw the entire circle.\n        If extent is not a full circle, one endpoint of the arc is the\n        current pen position. Draw the arc in counterclockwise direction\n        if radius is positive, otherwise in clockwise direction. Finally\n        the direction of the turtle is changed by the amount of extent.\n        As the circle is approximated by an inscribed regular polygon,\n        steps determines the number of steps to use. If not given,\n        it will be calculated automatically. Maybe used to draw regular\n        polygons.\n        call: circle(radius)                  # full circle\n        --or: circle(radius, extent)          # arc\n        --or: circle(radius, extent, steps)\n        --or: circle(radius, steps=6)         # 6-sided polygon\n        Example (for a Turtle instance named turtle):\n        >>> turtle.circle(50)\n        >>> turtle.circle(120, 180)  # semicircle\n        \"\"\"\n        if self.undobuffer:\n            self.undobuffer.push([\"seq\"])\n            self.undobuffer.cumulate = True\n        speed = self.speed()\n        if extent is None:\n            extent = self._fullcircle\n        if steps is None:\n            frac = abs(extent)\/self._fullcircle\n            steps = 1+int(min(11+abs(radius)\/6.0, 59.0)*frac)\n        w = 1.0 * extent \/ steps\n        w2 = 0.5 * w\n        l = 2.0 * radius * math.sin(w2*math.pi\/180.0*self._degreesPerAU)\n        if radius < 0:\n            l, w, w2 = -l, -w, -w2\n        tr = self._tracer()\n        dl = self._delay()\n        if speed == 0:\n            self._tracer(0, 0)\n        else:\n            self.speed(0)\n        self._rotate(w2)\n        for i in range(steps):\n            self.speed(speed)\n            self._go(l)\n            self.speed(0)\n            self._rotate(w)\n        self._rotate(-w2)\n        if speed == 0:\n            self._tracer(tr, dl)\n        self.speed(speed)\n        if self.undobuffer:\n            self.undobuffer.cumulate = False\n\n## three dummy methods to be implemented by child class:\n\n    def speed(self, s=0):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n    def _tracer(self, a=None, b=None):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n    def _delay(self, n=None):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n\n    fd = forward\n    bk = back\n    backward = back\n    rt = right\n    lt = left\n    position = pos\n    setpos = goto\n    setposition = goto\n    seth = setheading\n\n\nclass TPen(object):\n    \"\"\"Drawing part of the RawTurtle.\n    Implements drawing properties.\n    \"\"\"\n    def __init__(self, resizemode=_CFG[\"resizemode\"]):\n        self._resizemode = resizemode # or \"user\" or \"noresize\"\n        self.undobuffer = None\n        TPen._reset(self)\n\n    def _reset(self, pencolor=_CFG[\"pencolor\"],\n                     fillcolor=_CFG[\"fillcolor\"]):\n        self._pensize = 1\n        self._shown = True\n        self._pencolor = pencolor\n        self._fillcolor = fillcolor\n        self._drawing = True\n        self._speed = 3\n        self._stretchfactor = (1., 1.)\n        self._shearfactor = 0.\n        self._tilt = 0.\n        self._shapetrafo = (1., 0., 0., 1.)\n        self._outlinewidth = 1\n\n    def resizemode(self, rmode=None):\n        \"\"\"Set resizemode to one of the values: \"auto\", \"user\", \"noresize\".\n        (Optional) Argument:\n        rmode -- one of the strings \"auto\", \"user\", \"noresize\"\n        Different resizemodes have the following effects:\n          - \"auto\" adapts the appearance of the turtle\n                   corresponding to the value of pensize.\n          - \"user\" adapts the appearance of the turtle according to the\n                   values of stretchfactor and outlinewidth (outline),\n                   which are set by shapesize()\n          - \"noresize\" no adaption of the turtle\'s appearance takes place.\n        If no argument is given, return current resizemode.\n        resizemode(\"user\") is called by a call of shapesize with arguments.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.resizemode(\"noresize\")\n        >>> turtle.resizemode()\n        \'noresize\'\n        \"\"\"\n        if rmode is None:\n            return self._resizemode\n        rmode = rmode.lower()\n        if rmode in [\"auto\", \"user\", \"noresize\"]:\n            self.pen(resizemode=rmode)\n\n    def pensize(self, width=None):\n        \"\"\"Set or return the line thickness.\n        Aliases:  pensize | width\n        Argument:\n        width -- positive number\n        Set the line thickness to width or return it. If resizemode is set\n        to \"auto\" and turtleshape is a polygon, that polygon is drawn with\n        the same line thickness. If no argument is given, current pensize\n        is returned.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pensize()\n        1\n        >>> turtle.pensize(10)   # from here on lines of width 10 are drawn\n        \"\"\"\n        if width is None:\n            return self._pensize\n        self.pen(pensize=width)\n\n\n    def penup(self):\n        \"\"\"Pull the pen up -- no drawing when moving.\n        Aliases: penup | pu | up\n        No argument\n        Example (for a Turtle instance named turtle):\n        >>> turtle.penup()\n        \"\"\"\n        if not self._drawing:\n            return\n        self.pen(pendown=False)\n\n    def pendown(self):\n        \"\"\"Pull the pen down -- drawing when moving.\n        Aliases: pendown | pd | down\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pendown()\n        \"\"\"\n        if self._drawing:\n            return\n        self.pen(pendown=True)\n\n    def isdown(self):\n        \"\"\"Return True if pen is down, False if it\'s up.\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.penup()\n        >>> turtle.isdown()\n        False\n        >>> turtle.pendown()\n        >>> turtle.isdown()\n        True\n        \"\"\"\n        return self._drawing\n\n    def speed(self, speed=None):\n        \"\"\" Return or set the turtle\'s speed.\n        Optional argument:\n        speed -- an integer in the range 0..10 or a speedstring (see below)\n        Set the turtle\'s speed to an integer value in the range 0 .. 10.\n        If no argument is given: return current speed.\n        If input is a number greater than 10 or smaller than 0.5,\n        speed is set to 0.\n        Speedstrings  are mapped to speedvalues in the following way:\n            \'fastest\' :  0\n            \'fast\'    :  10\n            \'normal\'  :  6\n            \'slow\'    :  3\n            \'slowest\' :  1\n        speeds from 1 to 10 enforce increasingly faster animation of\n        line drawing and turtle turning.\n        Attention:\n        speed = 0 : *no* animation takes place. forward\/back makes turtle jump\n        and likewise left\/right make the turtle turn instantly.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.speed(3)\n        \"\"\"\n        speeds = {\'fastest\':0, \'fast\':10, \'normal\':6, \'slow\':3, \'slowest\':1 }\n        if speed is None:\n            return self._speed\n        if speed in speeds:\n            speed = speeds[speed]\n        elif 0.5 < speed < 10.5:\n            speed = int(round(speed))\n        else:\n            speed = 0\n        self.pen(speed=speed)\n\n    def color(self, *args):\n        \"\"\"Return or set the pencolor and fillcolor.\n        Arguments:\n        Several input formats are allowed.\n        They use 0, 1, 2, or 3 arguments as follows:\n        color()\n            Return the current pencolor and the current fillcolor\n            as a pair of color specification strings as are returned\n            by pencolor and fillcolor.\n        color(colorstring), color((r,g,b)), color(r,g,b)\n            inputs as in pencolor, set both, fillcolor and pencolor,\n            to the given value.\n        color(colorstring1, colorstring2),\n        color((r1,g1,b1), (r2,g2,b2))\n            equivalent to pencolor(colorstring1) and fillcolor(colorstring2)\n            and analogously, if the other input format is used.\n        If turtleshape is a polygon, outline and interior of that polygon\n        is drawn with the newly set colors.\n        For mor info see: pencolor, fillcolor\n        Example (for a Turtle instance named turtle):\n        >>> turtle.color(\'red\', \'green\')\n        >>> turtle.color()\n        (\'red\', \'green\')\n        >>> colormode(255)\n        >>> color((40, 80, 120), (160, 200, 240))\n        >>> color()\n        (\'#285078\', \'#a0c8f0\')\n        \"\"\"\n        if args:\n            l = len(args)\n            if l == 1:\n                pcolor = fcolor = args[0]\n            elif l == 2:\n                pcolor, fcolor = args\n            elif l == 3:\n                pcolor = fcolor = args\n            pcolor = self._colorstr(pcolor)\n            fcolor = self._colorstr(fcolor)\n            self.pen(pencolor=pcolor, fillcolor=fcolor)\n        else:\n            return self._color(self._pencolor), self._color(self._fillcolor)\n\n    def pencolor(self, *args):\n        \"\"\" Return or set the pencolor.\n        Arguments:\n        Four input formats are allowed:\n          - pencolor()\n            Return the current pencolor as color specification string,\n            possibly in hex-number format (see example).\n            May be used as input to another color\/pencolor\/fillcolor call.\n          - pencolor(colorstring)\n            s is a Tk color specification string, such as \"red\" or \"yellow\"\n          - pencolor((r, g, b))\n            *a tuple* of r, g, and b, which represent, an RGB color,\n            and each of r, g, and b are in the range 0..colormode,\n            where colormode is either 1.0 or 255\n          - pencolor(r, g, b)\n            r, g, and b represent an RGB color, and each of r, g, and b\n            are in the range 0..colormode\n        If turtleshape is a polygon, the outline of that polygon is drawn\n        with the newly set pencolor.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.pencolor(\'brown\')\n        >>> tup = (0.2, 0.8, 0.55)\n        >>> turtle.pencolor(tup)\n        >>> turtle.pencolor()\n        \'#33cc8c\'\n        \"\"\"\n        if args:\n            color = self._colorstr(args)\n            if color == self._pencolor:\n                return\n            self.pen(pencolor=color)\n        else:\n            return self._color(self._pencolor)\n\n    def fillcolor(self, *args):\n        \"\"\" Return or set the fillcolor.\n        Arguments:\n        Four input formats are allowed:\n          - fillcolor()\n            Return the current fillcolor as color specification string,\n            possibly in hex-number format (see example).\n            May be used as input to another color\/pencolor\/fillcolor call.\n          - fillcolor(colorstring)\n            s is a Tk color specification string, such as \"red\" or \"yellow\"\n          - fillcolor((r, g, b))\n            *a tuple* of r, g, and b, which represent, an RGB color,\n            and each of r, g, and b are in the range 0..colormode,\n            where colormode is either 1.0 or 255\n          - fillcolor(r, g, b)\n            r, g, and b represent an RGB color, and each of r, g, and b\n            are in the range 0..colormode\n        If turtleshape is a polygon, the interior of that polygon is drawn\n        with the newly set fillcolor.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.fillcolor(\'violet\')\n        >>> col = turtle.pencolor()\n        >>> turtle.fillcolor(col)\n        >>> turtle.fillcolor(0, .5, 0)\n        \"\"\"\n        if args:\n            color = self._colorstr(args)\n            if color == self._fillcolor:\n                return\n            self.pen(fillcolor=color)\n        else:\n            return self._color(self._fillcolor)\n\n    def showturtle(self):\n        \"\"\"Makes the turtle visible.\n        Aliases: showturtle | st\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.hideturtle()\n        >>> turtle.showturtle()\n        \"\"\"\n        self.pen(shown=True)\n\n    def hideturtle(self):\n        \"\"\"Makes the turtle invisible.\n        Aliases: hideturtle | ht\n        No argument.\n        It\'s a good idea to do this while you\'re in the\n        middle of a complicated drawing, because hiding\n        the turtle speeds up the drawing observably.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.hideturtle()\n        \"\"\"\n        self.pen(shown=False)\n\n    def isvisible(self):\n        \"\"\"Return True if the Turtle is shown, False if it\'s hidden.\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.hideturtle()\n        >>> print turtle.isvisible():\n        False\n        \"\"\"\n        return self._shown\n\n    def pen(self, pen=None, **pendict):\n        \"\"\"Return or set the pen\'s attributes.\n        Arguments:\n            pen -- a dictionary with some or all of the below listed keys.\n            **pendict -- one or more keyword-arguments with the below\n                         listed keys as keywords.\n        Return or set the pen\'s attributes in a \'pen-dictionary\'\n        with the following key\/value pairs:\n           \"shown\"      :   True\/False\n           \"pendown\"    :   True\/False\n           \"pencolor\"   :   color-string or color-tuple\n           \"fillcolor\"  :   color-string or color-tuple\n           \"pensize\"    :   positive number\n           \"speed\"      :   number in range 0..10\n           \"resizemode\" :   \"auto\" or \"user\" or \"noresize\"\n           \"stretchfactor\": (positive number, positive number)\n           \"shearfactor\":   number\n           \"outline\"    :   positive number\n           \"tilt\"       :   number\n        This dictionary can be used as argument for a subsequent\n        pen()-call to restore the former pen-state. Moreover one\n        or more of these attributes can be provided as keyword-arguments.\n        This can be used to set several pen attributes in one statement.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.pen(fillcolor=\"black\", pencolor=\"red\", pensize=10)\n        >>> turtle.pen()\n        {\'pensize\': 10, \'shown\': True, \'resizemode\': \'auto\', \'outline\': 1,\n        \'pencolor\': \'red\', \'pendown\': True, \'fillcolor\': \'black\',\n        \'stretchfactor\': (1,1), \'speed\': 3, \'shearfactor\': 0.0}\n        >>> penstate=turtle.pen()\n        >>> turtle.color(\"yellow\",\"\")\n        >>> turtle.penup()\n        >>> turtle.pen()\n        {\'pensize\': 10, \'shown\': True, \'resizemode\': \'auto\', \'outline\': 1,\n        \'pencolor\': \'yellow\', \'pendown\': False, \'fillcolor\': \'\',\n        \'stretchfactor\': (1,1), \'speed\': 3, \'shearfactor\': 0.0}\n        >>> p.pen(penstate, fillcolor=\"green\")\n        >>> p.pen()\n        {\'pensize\': 10, \'shown\': True, \'resizemode\': \'auto\', \'outline\': 1,\n        \'pencolor\': \'red\', \'pendown\': True, \'fillcolor\': \'green\',\n        \'stretchfactor\': (1,1), \'speed\': 3, \'shearfactor\': 0.0}\n        \"\"\"\n        _pd =  {\"shown\"         : self._shown,\n                \"pendown\"       : self._drawing,\n                \"pencolor\"      : self._pencolor,\n                \"fillcolor\"     : self._fillcolor,\n                \"pensize\"       : self._pensize,\n                \"speed\"         : self._speed,\n                \"resizemode\"    : self._resizemode,\n                \"stretchfactor\" : self._stretchfactor,\n                \"shearfactor\"   : self._shearfactor,\n                \"outline\"       : self._outlinewidth,\n                \"tilt\"          : self._tilt\n               }\n\n        if not (pen or pendict):\n            return _pd\n\n        if isinstance(pen, dict):\n            p = pen\n        else:\n            p = {}\n        p.update(pendict)\n\n        _p_buf = {}\n        for key in p:\n            _p_buf[key] = _pd[key]\n\n        if self.undobuffer:\n            self.undobuffer.push((\"pen\", _p_buf))\n\n        newLine = False\n        if \"pendown\" in p:\n            if self._drawing != p[\"pendown\"]:\n                newLine = True\n        if \"pencolor\" in p:\n            if isinstance(p[\"pencolor\"], tuple):\n                p[\"pencolor\"] = self._colorstr((p[\"pencolor\"],))\n            if self._pencolor != p[\"pencolor\"]:\n                newLine = True\n        if \"pensize\" in p:\n            if self._pensize != p[\"pensize\"]:\n                newLine = True\n        if newLine:\n            self._newLine()\n        if \"pendown\" in p:\n            self._drawing = p[\"pendown\"]\n        if \"pencolor\" in p:\n            self._pencolor = p[\"pencolor\"]\n        if \"pensize\" in p:\n            self._pensize = p[\"pensize\"]\n        if \"fillcolor\" in p:\n            if isinstance(p[\"fillcolor\"], tuple):\n                p[\"fillcolor\"] = self._colorstr((p[\"fillcolor\"],))\n            self._fillcolor = p[\"fillcolor\"]\n        if \"speed\" in p:\n            self._speed = p[\"speed\"]\n        if \"resizemode\" in p:\n            self._resizemode = p[\"resizemode\"]\n        if \"stretchfactor\" in p:\n            sf = p[\"stretchfactor\"]\n            if isinstance(sf, (int, float)):\n                sf = (sf, sf)\n            self._stretchfactor = sf\n        if \"shearfactor\" in p:\n            self._shearfactor = p[\"shearfactor\"]\n        if \"outline\" in p:\n            self._outlinewidth = p[\"outline\"]\n        if \"shown\" in p:\n            self._shown = p[\"shown\"]\n        if \"tilt\" in p:\n            self._tilt = p[\"tilt\"]\n        if \"stretchfactor\" in p or \"tilt\" in p or \"shearfactor\" in p:\n            scx, scy = self._stretchfactor\n            shf = self._shearfactor\n            sa, ca = math.sin(self._tilt), math.cos(self._tilt)\n            self._shapetrafo = ( scx*ca, scy*(shf*ca + sa),\n                                -scx*sa, scy*(ca - shf*sa))\n        self._update()\n\n## three dummy methods to be implemented by child class:\n\n    def _newLine(self, usePos = True):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n    def _update(self, count=True, forced=False):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n    def _color(self, args):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n    def _colorstr(self, args):\n        \"\"\"dummy method - to be overwritten by child class\"\"\"\n\n    width = pensize\n    up = penup\n    pu = penup\n    pd = pendown\n    down = pendown\n    st = showturtle\n    ht = hideturtle\n\n\nclass _TurtleImage(object):\n    \"\"\"Helper class: Datatype to store Turtle attributes\n    \"\"\"\n\n    def __init__(self, screen, shapeIndex):\n        self.screen = screen\n        self._type = None\n        self._setshape(shapeIndex)\n\n    def _setshape(self, shapeIndex):\n        screen = self.screen\n        self.shapeIndex = shapeIndex\n        if self._type == \"polygon\" == screen._shapes[shapeIndex]._type:\n            return\n        if self._type == \"image\" == screen._shapes[shapeIndex]._type:\n            return\n        if self._type in [\"image\", \"polygon\"]:\n            screen._delete(self._item)\n        elif self._type == \"compound\":\n            for item in self._item:\n                screen._delete(item)\n        self._type = screen._shapes[shapeIndex]._type\n        if self._type == \"polygon\":\n            self._item = screen._createpoly()\n        elif self._type == \"image\":\n            self._item = screen._createimage(screen._shapes[\"blank\"]._data)\n        elif self._type == \"compound\":\n            self._item = [screen._createpoly() for item in\n                                          screen._shapes[shapeIndex]._data]\n\n\nclass RawTurtle(TPen, TNavigator):\n    \"\"\"Animation part of the RawTurtle.\n    Puts RawTurtle upon a TurtleScreen and provides tools for\n    its animation.\n    \"\"\"\n    screens = []\n\n    def __init__(self, canvas=None,\n                 shape=_CFG[\"shape\"],\n                 undobuffersize=_CFG[\"undobuffersize\"],\n                 visible=_CFG[\"visible\"]):\n        if isinstance(canvas, _Screen):\n            self.screen = canvas\n        elif isinstance(canvas, TurtleScreen):\n            if canvas not in RawTurtle.screens:\n                RawTurtle.screens.append(canvas)\n            self.screen = canvas\n        elif isinstance(canvas, (ScrolledCanvas, Canvas)):\n            for screen in RawTurtle.screens:\n                if screen.cv == canvas:\n                    self.screen = screen\n                    break\n            else:\n                self.screen = TurtleScreen(canvas)\n                RawTurtle.screens.append(self.screen)\n        else:\n            raise TurtleGraphicsError(\"bad canvas argument %s\" % canvas)\n\n        screen = self.screen\n        TNavigator.__init__(self, screen.mode())\n        TPen.__init__(self)\n        screen._turtles.append(self)\n        self.drawingLineItem = screen._createline()\n        self.turtle = _TurtleImage(screen, shape)\n        self._poly = None\n        self._creatingPoly = False\n        self._fillitem = self._fillpath = None\n        self._shown = visible\n        self._hidden_from_screen = False\n        self.currentLineItem = screen._createline()\n        self.currentLine = [self._position]\n        self.items = [self.currentLineItem]\n        self.stampItems = []\n        self._undobuffersize = undobuffersize\n        self.undobuffer = Tbuffer(undobuffersize)\n        self._update()\n\n    def reset(self):\n        \"\"\"Delete the turtle\'s drawings and restore its default values.\n        No argument.\n        Delete the turtle\'s drawings from the screen, re-center the turtle\n        and set variables to the default values.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.position()\n        (0.00,-22.00)\n        >>> turtle.heading()\n        100.0\n        >>> turtle.reset()\n        >>> turtle.position()\n        (0.00,0.00)\n        >>> turtle.heading()\n        0.0\n        \"\"\"\n        TNavigator.reset(self)\n        TPen._reset(self)\n        self._clear()\n        self._drawturtle()\n        self._update()\n\n    def setundobuffer(self, size):\n        \"\"\"Set or disable undobuffer.\n        Argument:\n        size -- an integer or None\n        If size is an integer an empty undobuffer of given size is installed.\n        Size gives the maximum number of turtle-actions that can be undone\n        by the undo() function.\n        If size is None, no undobuffer is present.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.setundobuffer(42)\n        \"\"\"\n        if size is None or size <= 0:\n            self.undobuffer = None\n        else:\n            self.undobuffer = Tbuffer(size)\n\n    def undobufferentries(self):\n        \"\"\"Return count of entries in the undobuffer.\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> while undobufferentries():\n        ...     undo()\n        \"\"\"\n        if self.undobuffer is None:\n            return 0\n        return self.undobuffer.nr_of_items()\n\n    def _clear(self):\n        \"\"\"Delete all of pen\'s drawings\"\"\"\n        self._fillitem = self._fillpath = None\n        for item in self.items:\n            self.screen._delete(item)\n        self.currentLineItem = self.screen._createline()\n        self.currentLine = []\n        if self._drawing:\n            self.currentLine.append(self._position)\n        self.items = [self.currentLineItem]\n        self.clearstamps()\n        self.setundobuffer(self._undobuffersize)\n\n\n    def clear(self):\n        \"\"\"Delete the turtle\'s drawings from the screen. Do not move turtle.\n        No arguments.\n        Delete the turtle\'s drawings from the screen. Do not move turtle.\n        State and position of the turtle as well as drawings of other\n        turtles are not affected.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.clear()\n        \"\"\"\n        self._clear()\n        self._update()\n\n    def _update_data(self):\n        self.screen._incrementudc()\n        if self.screen._updatecounter != 0:\n            return\n        if len(self.currentLine)>1:\n            self.screen._drawline(self.currentLineItem, self.currentLine,\n                                  self._pencolor, self._pensize)\n\n    def _update(self):\n        \"\"\"Perform a Turtle-data update.\n        \"\"\"\n        screen = self.screen\n        if screen._tracing == 0:\n            return\n        elif screen._tracing == 1:\n            self._update_data()\n            self._drawturtle()\n            screen._update()                  # TurtleScreenBase\n            screen._delay(screen._delayvalue) # TurtleScreenBase\n        else:\n            self._update_data()\n            if screen._updatecounter == 0:\n                for t in screen.turtles():\n                    t._drawturtle()\n                screen._update()\n\n    def _tracer(self, flag=None, delay=None):\n        \"\"\"Turns turtle animation on\/off and set delay for update drawings.\n        Optional arguments:\n        n -- nonnegative  integer\n        delay -- nonnegative  integer\n        If n is given, only each n-th regular screen update is really performed.\n        (Can be used to accelerate the drawing of complex graphics.)\n        Second arguments sets delay value (see RawTurtle.delay())\n        Example (for a Turtle instance named turtle):\n        >>> turtle.tracer(8, 25)\n        >>> dist = 2\n        >>> for i in range(200):\n        ...     turtle.fd(dist)\n        ...     turtle.rt(90)\n        ...     dist += 2\n        \"\"\"\n        return self.screen.tracer(flag, delay)\n\n    def _color(self, args):\n        return self.screen._color(args)\n\n    def _colorstr(self, args):\n        return self.screen._colorstr(args)\n\n    def _cc(self, args):\n        \"\"\"Convert colortriples to hexstrings.\n        \"\"\"\n        if isinstance(args, str):\n            return args\n        try:\n            r, g, b = args\n        except:\n            raise TurtleGraphicsError(\"bad color arguments: %s\" % str(args))\n        if self.screen._colormode == 1.0:\n            r, g, b = [round(255.0*x) for x in (r, g, b)]\n        if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):\n            raise TurtleGraphicsError(\"bad color sequence: %s\" % str(args))\n        return \"#%02x%02x%02x\" % (r, g, b)\n\n    def clone(self):\n        \"\"\"Create and return a clone of the turtle.\n        No argument.\n        Create and return a clone of the turtle with same position, heading\n        and turtle properties.\n        Example (for a Turtle instance named mick):\n        mick = Turtle()\n        joe = mick.clone()\n        \"\"\"\n        screen = self.screen\n        self._newLine(self._drawing)\n\n        turtle = self.turtle\n        self.screen = None\n        self.turtle = None  # too make self deepcopy-able\n\n        q = deepcopy(self)\n\n        self.screen = screen\n        self.turtle = turtle\n\n        q.screen = screen\n        q.turtle = _TurtleImage(screen, self.turtle.shapeIndex)\n\n        screen._turtles.append(q)\n        ttype = screen._shapes[self.turtle.shapeIndex]._type\n        if ttype == \"polygon\":\n            q.turtle._item = screen._createpoly()\n        elif ttype == \"image\":\n            q.turtle._item = screen._createimage(screen._shapes[\"blank\"]._data)\n        elif ttype == \"compound\":\n            q.turtle._item = [screen._createpoly() for item in\n                              screen._shapes[self.turtle.shapeIndex]._data]\n        q.currentLineItem = screen._createline()\n        q._update()\n        return q\n\n    def shape(self, name=None):\n        \"\"\"Set turtle shape to shape with given name \/ return current shapename.\n        Optional argument:\n        name -- a string, which is a valid shapename\n        Set turtle shape to shape with given name or, if name is not given,\n        return name of current shape.\n        Shape with name must exist in the TurtleScreen\'s shape dictionary.\n        Initially there are the following polygon shapes:\n        \'arrow\', \'turtle\', \'circle\', \'square\', \'triangle\', \'classic\'.\n        To learn about how to deal with shapes see Screen-method register_shape.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.shape()\n        \'arrow\'\n        >>> turtle.shape(\"turtle\")\n        >>> turtle.shape()\n        \'turtle\'\n        \"\"\"\n        if name is None:\n            return self.turtle.shapeIndex\n        if not name in self.screen.getshapes():\n            raise TurtleGraphicsError(\"There is no shape named %s\" % name)\n        self.turtle._setshape(name)\n        self._update()\n\n    def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):\n        \"\"\"Set\/return turtle\'s stretchfactors\/outline. Set resizemode to \"user\".\n        Optional arguments:\n           stretch_wid : positive number\n           stretch_len : positive number\n           outline  : positive number\n        Return or set the pen\'s attributes x\/y-stretchfactors and\/or outline.\n        Set resizemode to \"user\".\n        If and only if resizemode is set to \"user\", the turtle will be displayed\n        stretched according to its stretchfactors:\n        stretch_wid is stretchfactor perpendicular to orientation\n        stretch_len is stretchfactor in direction of turtles orientation.\n        outline determines the width of the shapes\'s outline.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.resizemode(\"user\")\n        >>> turtle.shapesize(5, 5, 12)\n        >>> turtle.shapesize(outline=8)\n        \"\"\"\n        if stretch_wid is stretch_len is outline is None:\n            stretch_wid, stretch_len = self._stretchfactor\n            return stretch_wid, stretch_len, self._outlinewidth\n        if stretch_wid == 0 or stretch_len == 0:\n            raise TurtleGraphicsError(\"stretch_wid\/stretch_len must not be zero\")\n        if stretch_wid is not None:\n            if stretch_len is None:\n                stretchfactor = stretch_wid, stretch_wid\n            else:\n                stretchfactor = stretch_wid, stretch_len\n        elif stretch_len is not None:\n            stretchfactor = self._stretchfactor[0], stretch_len\n        else:\n            stretchfactor = self._stretchfactor\n        if outline is None:\n            outline = self._outlinewidth\n        self.pen(resizemode=\"user\",\n                 stretchfactor=stretchfactor, outline=outline)\n\n    def shearfactor(self, shear=None):\n        \"\"\"Set or return the current shearfactor.\n        Optional argument: shear -- number, tangent of the shear angle\n        Shear the turtleshape according to the given shearfactor shear,\n        which is the tangent of the shear angle. DO NOT change the\n        turtle\'s heading (direction of movement).\n        If shear is not given: return the current shearfactor, i. e. the\n        tangent of the shear angle, by which lines parallel to the\n        heading of the turtle are sheared.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"circle\")\n        >>> turtle.shapesize(5,2)\n        >>> turtle.shearfactor(0.5)\n        >>> turtle.shearfactor()\n        >>> 0.5\n        \"\"\"\n        if shear is None:\n            return self._shearfactor\n        self.pen(resizemode=\"user\", shearfactor=shear)\n\n    def settiltangle(self, angle):\n        \"\"\"Rotate the turtleshape to point in the specified direction\n        Argument: angle -- number\n        Rotate the turtleshape to point in the direction specified by angle,\n        regardless of its current tilt-angle. DO NOT change the turtle\'s\n        heading (direction of movement).\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"circle\")\n        >>> turtle.shapesize(5,2)\n        >>> turtle.settiltangle(45)\n        >>> stamp()\n        >>> turtle.fd(50)\n        >>> turtle.settiltangle(-45)\n        >>> stamp()\n        >>> turtle.fd(50)\n        \"\"\"\n        tilt = -angle * self._degreesPerAU * self._angleOrient\n        tilt = (tilt * math.pi \/ 180.0) % (2*math.pi)\n        self.pen(resizemode=\"user\", tilt=tilt)\n\n    def tiltangle(self, angle=None):\n        \"\"\"Set or return the current tilt-angle.\n        Optional argument: angle -- number\n        Rotate the turtleshape to point in the direction specified by angle,\n        regardless of its current tilt-angle. DO NOT change the turtle\'s\n        heading (direction of movement).\n        If angle is not given: return the current tilt-angle, i. e. the angle\n        between the orientation of the turtleshape and the heading of the\n        turtle (its direction of movement).\n        Deprecated since Python 3.1\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"circle\")\n        >>> turtle.shapesize(5,2)\n        >>> turtle.tilt(45)\n        >>> turtle.tiltangle()\n        \"\"\"\n        if angle is None:\n            tilt = -self._tilt * (180.0\/math.pi) * self._angleOrient\n            return (tilt \/ self._degreesPerAU) % self._fullcircle\n        else:\n            self.settiltangle(angle)\n\n    def tilt(self, angle):\n        \"\"\"Rotate the turtleshape by angle.\n        Argument:\n        angle - a number\n        Rotate the turtleshape by angle from its current tilt-angle,\n        but do NOT change the turtle\'s heading (direction of movement).\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"circle\")\n        >>> turtle.shapesize(5,2)\n        >>> turtle.tilt(30)\n        >>> turtle.fd(50)\n        >>> turtle.tilt(30)\n        >>> turtle.fd(50)\n        \"\"\"\n        self.settiltangle(angle + self.tiltangle())\n\n    def shapetransform(self, t11=None, t12=None, t21=None, t22=None):\n        \"\"\"Set or return the current transformation matrix of the turtle shape.\n        Optional arguments: t11, t12, t21, t22 -- numbers.\n        If none of the matrix elements are given, return the transformation\n        matrix.\n        Otherwise set the given elements and transform the turtleshape\n        according to the matrix consisting of first row t11, t12 and\n        second row t21, 22.\n        Modify stretchfactor, shearfactor and tiltangle according to the\n        given matrix.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"square\")\n        >>> turtle.shapesize(4,2)\n        >>> turtle.shearfactor(-0.5)\n        >>> turtle.shapetransform()\n        (4.0, -1.0, -0.0, 2.0)\n        \"\"\"\n        if t11 is t12 is t21 is t22 is None:\n            return self._shapetrafo\n        m11, m12, m21, m22 = self._shapetrafo\n        if t11 is not None: m11 = t11\n        if t12 is not None: m12 = t12\n        if t21 is not None: m21 = t21\n        if t22 is not None: m22 = t22\n        if t11 * t22 - t12 * t21 == 0:\n            raise TurtleGraphicsError(\"Bad shape transform matrix: must not be singular\")\n        self._shapetrafo = (m11, m12, m21, m22)\n        alfa = math.atan2(-m21, m11) % (2 * math.pi)\n        sa, ca = math.sin(alfa), math.cos(alfa)\n        a11, a12, a21, a22 = (ca*m11 - sa*m21, ca*m12 - sa*m22,\n                              sa*m11 + ca*m21, sa*m12 + ca*m22)\n        self._stretchfactor = a11, a22\n        self._shearfactor = a12\/a22\n        self._tilt = alfa\n        self.pen(resizemode=\"user\")\n\n\n    def _polytrafo(self, poly):\n        \"\"\"Computes transformed polygon shapes from a shape\n        according to current position and heading.\n        \"\"\"\n        screen = self.screen\n        p0, p1 = self._position\n        e0, e1 = self._orient\n        e = Vec2D(e0, e1 * screen.yscale \/ screen.xscale)\n        e0, e1 = (1.0 \/ abs(e)) * e\n        return [(p0+(e1*x+e0*y)\/screen.xscale, p1+(-e0*x+e1*y)\/screen.yscale)\n                                                           for (x, y) in poly]\n\n    def get_shapepoly(self):\n        \"\"\"Return the current shape polygon as tuple of coordinate pairs.\n        No argument.\n        Examples (for a Turtle instance named turtle):\n        >>> turtle.shape(\"square\")\n        >>> turtle.shapetransform(4, -1, 0, 2)\n        >>> turtle.get_shapepoly()\n        ((50, -20), (30, 20), (-50, 20), (-30, -20))\n        \"\"\"\n        shape = self.screen._shapes[self.turtle.shapeIndex]\n        if shape._type == \"polygon\":\n            return self._getshapepoly(shape._data, shape._type == \"compound\")\n        # else return None\n\n    def _getshapepoly(self, polygon, compound=False):\n        \"\"\"Calculate transformed shape polygon according to resizemode\n        and shapetransform.\n        \"\"\"\n        if self._resizemode == \"user\" or compound:\n            t11, t12, t21, t22 = self._shapetrafo\n        elif self._resizemode == \"auto\":\n            l = max(1, self._pensize\/5.0)\n            t11, t12, t21, t22 = l, 0, 0, l\n        elif self._resizemode == \"noresize\":\n            return polygon\n        return tuple([(t11*x + t12*y, t21*x + t22*y) for (x, y) in polygon])\n\n    def _drawturtle(self):\n        \"\"\"Manages the correct rendering of the turtle with respect to\n        its shape, resizemode, stretch and tilt etc.\"\"\"\n        screen = self.screen\n        shape = screen._shapes[self.turtle.shapeIndex]\n        ttype = shape._type\n        titem = self.turtle._item\n        if self._shown and screen._updatecounter == 0 and screen._tracing > 0:\n            self._hidden_from_screen = False\n            tshape = shape._data\n            if ttype == \"polygon\":\n                if self._resizemode == \"noresize\": w = 1\n                elif self._resizemode == \"auto\": w = self._pensize\n                else: w =self._outlinewidth\n                shape = self._polytrafo(self._getshapepoly(tshape))\n                fc, oc = self._fillcolor, self._pencolor\n                screen._drawpoly(titem, shape, fill=fc, outline=oc,\n                                                      width=w, top=True)\n            elif ttype == \"image\":\n                screen._drawimage(titem, self._position, tshape)\n            elif ttype == \"compound\":\n                for item, (poly, fc, oc) in zip(titem, tshape):\n                    poly = self._polytrafo(self._getshapepoly(poly, True))\n                    screen._drawpoly(item, poly, fill=self._cc(fc),\n                                     outline=self._cc(oc), width=self._outlinewidth, top=True)\n        else:\n            if self._hidden_from_screen:\n                return\n            if ttype == \"polygon\":\n                screen._drawpoly(titem, ((0, 0), (0, 0), (0, 0)), \"\", \"\")\n            elif ttype == \"image\":\n                screen._drawimage(titem, self._position,\n                                          screen._shapes[\"blank\"]._data)\n            elif ttype == \"compound\":\n                for item in titem:\n                    screen._drawpoly(item, ((0, 0), (0, 0), (0, 0)), \"\", \"\")\n            self._hidden_from_screen = True\n\n##############################  stamp stuff  ###############################\n\n    def stamp(self):\n        \"\"\"Stamp a copy of the turtleshape onto the canvas and return its id.\n        No argument.\n        Stamp a copy of the turtle shape onto the canvas at the current\n        turtle position. Return a stamp_id for that stamp, which can be\n        used to delete it by calling clearstamp(stamp_id).\n        Example (for a Turtle instance named turtle):\n        >>> turtle.color(\"blue\")\n        >>> turtle.stamp()\n        13\n        >>> turtle.fd(50)\n        \"\"\"\n        screen = self.screen\n        shape = screen._shapes[self.turtle.shapeIndex]\n        ttype = shape._type\n        tshape = shape._data\n        if ttype == \"polygon\":\n            stitem = screen._createpoly()\n            if self._resizemode == \"noresize\": w = 1\n            elif self._resizemode == \"auto\": w = self._pensize\n            else: w =self._outlinewidth\n            shape = self._polytrafo(self._getshapepoly(tshape))\n            fc, oc = self._fillcolor, self._pencolor\n            screen._drawpoly(stitem, shape, fill=fc, outline=oc,\n                                                  width=w, top=True)\n        elif ttype == \"image\":\n            stitem = screen._createimage(\"\")\n            screen._drawimage(stitem, self._position, tshape)\n        elif ttype == \"compound\":\n            stitem = []\n            for element in tshape:\n                item = screen._createpoly()\n                stitem.append(item)\n            stitem = tuple(stitem)\n            for item, (poly, fc, oc) in zip(stitem, tshape):\n                poly = self._polytrafo(self._getshapepoly(poly, True))\n                screen._drawpoly(item, poly, fill=self._cc(fc),\n                                 outline=self._cc(oc), width=self._outlinewidth, top=True)\n        self.stampItems.append(stitem)\n        self.undobuffer.push((\"stamp\", stitem))\n        return stitem\n\n    def _clearstamp(self, stampid):\n        \"\"\"does the work for clearstamp() and clearstamps()\n        \"\"\"\n        if stampid in self.stampItems:\n            if isinstance(stampid, tuple):\n                for subitem in stampid:\n                    self.screen._delete(subitem)\n            else:\n                self.screen._delete(stampid)\n            self.stampItems.remove(stampid)\n        # Delete stampitem from undobuffer if necessary\n        # if clearstamp is called directly.\n        item = (\"stamp\", stampid)\n        buf = self.undobuffer\n        if item not in buf.buffer:\n            return\n        index = buf.buffer.index(item)\n        buf.buffer.remove(item)\n        if index <= buf.ptr:\n            buf.ptr = (buf.ptr - 1) % buf.bufsize\n        buf.buffer.insert((buf.ptr+1)%buf.bufsize, [None])\n\n    def clearstamp(self, stampid):\n        \"\"\"Delete stamp with given stampid\n        Argument:\n        stampid - an integer, must be return value of previous stamp() call.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.color(\"blue\")\n        >>> astamp = turtle.stamp()\n        >>> turtle.fd(50)\n        >>> turtle.clearstamp(astamp)\n        \"\"\"\n        self._clearstamp(stampid)\n        self._update()\n\n    def clearstamps(self, n=None):\n        \"\"\"Delete all or first\/last n of turtle\'s stamps.\n        Optional argument:\n        n -- an integer\n        If n is None, delete all of pen\'s stamps,\n        else if n > 0 delete first n stamps\n        else if n < 0 delete last n stamps.\n        Example (for a Turtle instance named turtle):\n        >>> for i in range(8):\n        ...     turtle.stamp(); turtle.fd(30)\n        ...\n        >>> turtle.clearstamps(2)\n        >>> turtle.clearstamps(-2)\n        >>> turtle.clearstamps()\n        \"\"\"\n        if n is None:\n            toDelete = self.stampItems[:]\n        elif n >= 0:\n            toDelete = self.stampItems[:n]\n        else:\n            toDelete = self.stampItems[n:]\n        for item in toDelete:\n            self._clearstamp(item)\n        self._update()\n\n    def _goto(self, end):\n        \"\"\"Move the pen to the point end, thereby drawing a line\n        if pen is down. All other methods for turtle movement depend\n        on this one.\n        \"\"\"\n        ## Version with undo-stuff\n        go_modes = ( self._drawing,\n                     self._pencolor,\n                     self._pensize,\n                     isinstance(self._fillpath, list))\n        screen = self.screen\n        undo_entry = (\"go\", self._position, end, go_modes,\n                      (self.currentLineItem,\n                      self.currentLine[:],\n                      screen._pointlist(self.currentLineItem),\n                      self.items[:])\n                      )\n        if self.undobuffer:\n            self.undobuffer.push(undo_entry)\n        start = self._position\n        if self._speed and screen._tracing == 1:\n            diff = (end-start)\n            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2\n            nhops = 1+int((diffsq**0.5)\/(3*(1.1**self._speed)*self._speed))\n            delta = diff * (1.0\/nhops)\n            for n in range(1, nhops):\n                if n == 1:\n                    top = True\n                else:\n                    top = False\n                self._position = start + delta * n\n                if self._drawing:\n                    screen._drawline(self.drawingLineItem,\n                                     (start, self._position),\n                                     self._pencolor, self._pensize, top)\n                self._update()\n            if self._drawing:\n                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),\n                                               fill=\"\", width=self._pensize)\n        # Turtle now at end,\n        if self._drawing: # now update currentLine\n            self.currentLine.append(end)\n        if isinstance(self._fillpath, list):\n            self._fillpath.append(end)\n        ######    vererbung!!!!!!!!!!!!!!!!!!!!!!\n        self._position = end\n        if self._creatingPoly:\n            self._poly.append(end)\n        if len(self.currentLine) > 42: # 42! answer to the ultimate question\n                                       # of life, the universe and everything\n            self._newLine()\n        self._update() #count=True)\n\n    def _undogoto(self, entry):\n        \"\"\"Reverse a _goto. Used for undo()\n        \"\"\"\n        old, new, go_modes, coodata = entry\n        drawing, pc, ps, filling = go_modes\n        cLI, cL, pl, items = coodata\n        screen = self.screen\n        if abs(self._position - new) > 0.5:\n            print (\"undogoto: HALLO-DA-STIMMT-WAS-NICHT!\")\n        # restore former situation\n        self.currentLineItem = cLI\n        self.currentLine = cL\n\n        if pl == [(0, 0), (0, 0)]:\n            usepc = \"\"\n        else:\n            usepc = pc\n        screen._drawline(cLI, pl, fill=usepc, width=ps)\n\n        todelete = [i for i in self.items if (i not in items) and\n                                       (screen._type(i) == \"line\")]\n        for i in todelete:\n            screen._delete(i)\n            self.items.remove(i)\n\n        start = old\n        if self._speed and screen._tracing == 1:\n            diff = old - new\n            diffsq = (diff[0]*screen.xscale)**2 + (diff[1]*screen.yscale)**2\n            nhops = 1+int((diffsq**0.5)\/(3*(1.1**self._speed)*self._speed))\n            delta = diff * (1.0\/nhops)\n            for n in range(1, nhops):\n                if n == 1:\n                    top = True\n                else:\n                    top = False\n                self._position = new + delta * n\n                if drawing:\n                    screen._drawline(self.drawingLineItem,\n                                     (start, self._position),\n                                     pc, ps, top)\n                self._update()\n            if drawing:\n                screen._drawline(self.drawingLineItem, ((0, 0), (0, 0)),\n                                               fill=\"\", width=ps)\n        # Turtle now at position old,\n        self._position = old\n        ##  if undo is done during creating a polygon, the last vertex\n        ##  will be deleted. if the polygon is entirely deleted,\n        ##  creatingPoly will be set to False.\n        ##  Polygons created before the last one will not be affected by undo()\n        if self._creatingPoly:\n            if len(self._poly) > 0:\n                self._poly.pop()\n            if self._poly == []:\n                self._creatingPoly = False\n                self._poly = None\n        if filling:\n            if self._fillpath == []:\n                self._fillpath = None\n                print(\"Unwahrscheinlich in _undogoto!\")\n            elif self._fillpath is not None:\n                self._fillpath.pop()\n        self._update() #count=True)\n\n    def _rotate(self, angle):\n        \"\"\"Turns pen clockwise by angle.\n        \"\"\"\n        if self.undobuffer:\n            self.undobuffer.push((\"rot\", angle, self._degreesPerAU))\n        angle *= self._degreesPerAU\n        neworient = self._orient.rotate(angle)\n        tracing = self.screen._tracing\n        if tracing == 1 and self._speed > 0:\n            anglevel = 3.0 * self._speed\n            steps = 1 + int(abs(angle)\/anglevel)\n            delta = 1.0*angle\/steps\n            for _ in range(steps):\n                self._orient = self._orient.rotate(delta)\n                self._update()\n        self._orient = neworient\n        self._update()\n\n    def _newLine(self, usePos=True):\n        \"\"\"Closes current line item and starts a new one.\n           Remark: if current line became too long, animation\n           performance (via _drawline) slowed down considerably.\n        \"\"\"\n        if len(self.currentLine) > 1:\n            self.screen._drawline(self.currentLineItem, self.currentLine,\n                                      self._pencolor, self._pensize)\n            self.currentLineItem = self.screen._createline()\n            self.items.append(self.currentLineItem)\n        else:\n            self.screen._drawline(self.currentLineItem, top=True)\n        self.currentLine = []\n        if usePos:\n            self.currentLine = [self._position]\n\n    def filling(self):\n        \"\"\"Return fillstate (True if filling, False else).\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.begin_fill()\n        >>> if turtle.filling():\n        ...     turtle.pensize(5)\n        ... else:\n        ...     turtle.pensize(3)\n        \"\"\"\n        return isinstance(self._fillpath, list)\n\n    def begin_fill(self):\n        \"\"\"Called just before drawing a shape to be filled.\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.color(\"black\", \"red\")\n        >>> turtle.begin_fill()\n        >>> turtle.circle(60)\n        >>> turtle.end_fill()\n        \"\"\"\n        if not self.filling():\n            self._fillitem = self.screen._createpoly()\n            self.items.append(self._fillitem)\n        self._fillpath = [self._position]\n        self._newLine()\n        if self.undobuffer:\n            self.undobuffer.push((\"beginfill\", self._fillitem))\n        self._update()\n\n\n    def end_fill(self):\n        \"\"\"Fill the shape drawn after the call begin_fill().\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.color(\"black\", \"red\")\n        >>> turtle.begin_fill()\n        >>> turtle.circle(60)\n        >>> turtle.end_fill()\n        \"\"\"\n        if self.filling():\n            if len(self._fillpath) > 2:\n                self.screen._drawpoly(self._fillitem, self._fillpath,\n                                      fill=self._fillcolor)\n                if self.undobuffer:\n                    self.undobuffer.push((\"dofill\", self._fillitem))\n            self._fillitem = self._fillpath = None\n            self._update()\n\n    def dot(self, size=None, *color):\n        \"\"\"Draw a dot with diameter size, using color.\n        Optional arguments:\n        size -- an integer >= 1 (if given)\n        color -- a colorstring or a numeric color tuple\n        Draw a circular dot with diameter size, using color.\n        If size is not given, the maximum of pensize+4 and 2*pensize is used.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.dot()\n        >>> turtle.fd(50); turtle.dot(20, \"blue\"); turtle.fd(50)\n        \"\"\"\n        if not color:\n            if isinstance(size, (str, tuple)):\n                color = self._colorstr(size)\n                size = self._pensize + max(self._pensize, 4)\n            else:\n                color = self._pencolor\n                if not size:\n                    size = self._pensize + max(self._pensize, 4)\n        else:\n            if size is None:\n                size = self._pensize + max(self._pensize, 4)\n            color = self._colorstr(color)\n        if hasattr(self.screen, \"_dot\"):\n            item = self.screen._dot(self._position, size, color)\n            self.items.append(item)\n            if self.undobuffer:\n                self.undobuffer.push((\"dot\", item))\n        else:\n            pen = self.pen()\n            if self.undobuffer:\n                self.undobuffer.push([\"seq\"])\n                self.undobuffer.cumulate = True\n            try:\n                if self.resizemode() == \'auto\':\n                    self.ht()\n                self.pendown()\n                self.pensize(size)\n                self.pencolor(color)\n                self.forward(0)\n            finally:\n                self.pen(pen)\n            if self.undobuffer:\n                self.undobuffer.cumulate = False\n\n    def _write(self, txt, align, font):\n        \"\"\"Performs the writing for write()\n        \"\"\"\n        item, end = self.screen._write(self._position, txt, align, font,\n                                                          self._pencolor)\n        self.items.append(item)\n        if self.undobuffer:\n            self.undobuffer.push((\"wri\", item))\n        return end\n\n    def write(self, arg, move=False, align=\"left\", font=(\"Arial\", 8, \"normal\")):\n        \"\"\"Write text at the current turtle position.\n        Arguments:\n        arg -- info, which is to be written to the TurtleScreen\n        move (optional) -- True\/False\n        align (optional) -- one of the strings \"left\", \"center\" or right\"\n        font (optional) -- a triple (fontname, fontsize, fonttype)\n        Write text - the string representation of arg - at the current\n        turtle position according to align (\"left\", \"center\" or right\")\n        and with the given font.\n        If move is True, the pen is moved to the bottom-right corner\n        of the text. By default, move is False.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.write(\'Home = \', True, align=\"center\")\n        >>> turtle.write((0,0), True)\n        \"\"\"\n        if self.undobuffer:\n            self.undobuffer.push([\"seq\"])\n            self.undobuffer.cumulate = True\n        end = self._write(str(arg), align.lower(), font)\n        if move:\n            x, y = self.pos()\n            self.setpos(end, y)\n        if self.undobuffer:\n            self.undobuffer.cumulate = False\n\n    def begin_poly(self):\n        \"\"\"Start recording the vertices of a polygon.\n        No argument.\n        Start recording the vertices of a polygon. Current turtle position\n        is first point of polygon.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.begin_poly()\n        \"\"\"\n        self._poly = [self._position]\n        self._creatingPoly = True\n\n    def end_poly(self):\n        \"\"\"Stop recording the vertices of a polygon.\n        No argument.\n        Stop recording the vertices of a polygon. Current turtle position is\n        last point of polygon. This will be connected with the first point.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.end_poly()\n        \"\"\"\n        self._creatingPoly = False\n\n    def get_poly(self):\n        \"\"\"Return the lastly recorded polygon.\n        No argument.\n        Example (for a Turtle instance named turtle):\n        >>> p = turtle.get_poly()\n        >>> turtle.register_shape(\"myFavouriteShape\", p)\n        \"\"\"\n        ## check if there is any poly?\n        if self._poly is not None:\n            return tuple(self._poly)\n\n    def getscreen(self):\n        \"\"\"Return the TurtleScreen object, the turtle is drawing  on.\n        No argument.\n        Return the TurtleScreen object, the turtle is drawing  on.\n        So TurtleScreen-methods can be called for that object.\n        Example (for a Turtle instance named turtle):\n        >>> ts = turtle.getscreen()\n        >>> ts\n        <turtle.TurtleScreen object at 0x0106B770>\n        >>> ts.bgcolor(\"pink\")\n        \"\"\"\n        return self.screen\n\n    def getturtle(self):\n        \"\"\"Return the Turtleobject itself.\n        No argument.\n        Only reasonable use: as a function to return the \'anonymous turtle\':\n        Example:\n        >>> pet = getturtle()\n        >>> pet.fd(50)\n        >>> pet\n        <turtle.Turtle object at 0x0187D810>\n        >>> turtles()\n        [<turtle.Turtle object at 0x0187D810>]\n        \"\"\"\n        return self\n\n    getpen = getturtle\n\n\n    ################################################################\n    ### screen oriented methods recurring to methods of TurtleScreen\n    ################################################################\n\n    def _delay(self, delay=None):\n        \"\"\"Set delay value which determines speed of turtle animation.\n        \"\"\"\n        return self.screen.delay(delay)\n\n    def onclick(self, fun, btn=1, add=None):\n        \"\"\"Bind fun to mouse-click event on this turtle on canvas.\n        Arguments:\n        fun --  a function with two arguments, to which will be assigned\n                the coordinates of the clicked point on the canvas.\n        num --  number of the mouse-button defaults to 1 (left mouse button).\n        add --  True or False. If True, new binding will be added, otherwise\n                it will replace a former binding.\n        Example for the anonymous turtle, i. e. the procedural way:\n        >>> def turn(x, y):\n        ...     left(360)\n        ...\n        >>> onclick(turn)  # Now clicking into the turtle will turn it.\n        >>> onclick(None)  # event-binding will be removed\n        \"\"\"\n        self.screen._onclick(self.turtle._item, fun, btn, add)\n        self._update()\n\n    def onrelease(self, fun, btn=1, add=None):\n        \"\"\"Bind fun to mouse-button-release event on this turtle on canvas.\n        Arguments:\n        fun -- a function with two arguments, to which will be assigned\n                the coordinates of the clicked point on the canvas.\n        num --  number of the mouse-button defaults to 1 (left mouse button).\n        Example (for a MyTurtle instance named joe):\n        >>> class MyTurtle(Turtle):\n        ...     def glow(self,x,y):\n        ...             self.fillcolor(\"red\")\n        ...     def unglow(self,x,y):\n        ...             self.fillcolor(\"\")\n        ...\n        >>> joe = MyTurtle()\n        >>> joe.onclick(joe.glow)\n        >>> joe.onrelease(joe.unglow)\n        Clicking on joe turns fillcolor red, unclicking turns it to\n        transparent.\n        \"\"\"\n        self.screen._onrelease(self.turtle._item, fun, btn, add)\n        self._update()\n\n    def ondrag(self, fun, btn=1, add=None):\n        \"\"\"Bind fun to mouse-move event on this turtle on canvas.\n        Arguments:\n        fun -- a function with two arguments, to which will be assigned\n               the coordinates of the clicked point on the canvas.\n        num -- number of the mouse-button defaults to 1 (left mouse button).\n        Every sequence of mouse-move-events on a turtle is preceded by a\n        mouse-click event on that turtle.\n        Example (for a Turtle instance named turtle):\n        >>> turtle.ondrag(turtle.goto)\n        Subsequently clicking and dragging a Turtle will move it\n        across the screen thereby producing handdrawings (if pen is\n        down).\n        \"\"\"\n        self.screen._ondrag(self.turtle._item, fun, btn, add)\n\n\n    def _undo(self, action, data):\n        \"\"\"Does the main part of the work for undo()\n        \"\"\"\n        if self.undobuffer is None:\n            return\n        if action == \"rot\":\n            angle, degPAU = data\n            self._rotate(-angle*degPAU\/self._degreesPerAU)\n            dummy = self.undobuffer.pop()\n        elif action == \"stamp\":\n            stitem = data[0]\n            self.clearstamp(stitem)\n        elif action == \"go\":\n            self._undogoto(data)\n        elif action in [\"wri\", \"dot\"]:\n            item = data[0]\n            self.screen._delete(item)\n            self.items.remove(item)\n        elif action == \"dofill\":\n            item = data[0]\n            self.screen._drawpoly(item, ((0, 0),(0, 0),(0, 0)),\n                                  fill=\"\", outline=\"\")\n        elif action == \"beginfill\":\n            item = data[0]\n            self._fillitem = self._fillpath = None\n            if item in self.items:\n                self.screen._delete(item)\n                self.items.remove(item)\n        elif action == \"pen\":\n            TPen.pen(self, data[0])\n            self.undobuffer.pop()\n\n    def undo(self):\n        \"\"\"undo (repeatedly) the last turtle action.\n        No argument.\n        undo (repeatedly) the last turtle action.\n        Number of available undo actions is determined by the size of\n        the undobuffer.\n        Example (for a Turtle instance named turtle):\n        >>> for i in range(4):\n        ...     turtle.fd(50); turtle.lt(80)\n        ...\n        >>> for i in range(8):\n        ...     turtle.undo()\n        ...\n        \"\"\"\n        if self.undobuffer is None:\n            return\n        item = self.undobuffer.pop()\n        action = item[0]\n        data = item[1:]\n        if action == \"seq\":\n            while data:\n                item = data.pop()\n                self._undo(item[0], item[1:])\n        else:\n            self._undo(action, data)\n\n    turtlesize = shapesize\n\nRawPen = RawTurtle\n\n###  Screen - Singleton  ########################\n\ndef Screen():\n    \"\"\"Return the singleton screen object.\n    If none exists at the moment, create a new one and return it,\n    else return the existing one.\"\"\"\n    Turtle._screen = TurtleScreen(WebCanvas())\n    return Turtle._screen\n\nclass _Screen(TurtleScreen):\n\n    _root = None\n    _canvas = None\n    _title = _CFG[\"title\"]\n\n    def __init__(self):\n        # XXX there is no need for this code to be conditional,\n        # as there will be only a single _Screen instance, anyway\n        # XXX actually, the turtle demo is injecting root window,\n        # so perhaps the conditional creation of a root should be\n        # preserved (perhaps by passing it as an optional parameter)\n        if _Screen._root is None:\n            _Screen._root = self._root = _Root()\n            self._root.title(_Screen._title)\n            self._root.ondestroy(self._destroy)\n        if _Screen._canvas is None:\n            width = _CFG[\"width\"]\n            height = _CFG[\"height\"]\n            canvwidth = _CFG[\"canvwidth\"]\n            canvheight = _CFG[\"canvheight\"]\n            leftright = _CFG[\"leftright\"]\n            topbottom = _CFG[\"topbottom\"]\n            self._root.setupcanvas(width, height, canvwidth, canvheight)\n            _Screen._canvas = self._root._getcanvas()\n            TurtleScreen.__init__(self, _Screen._canvas)\n            self.setup(width, height, leftright, topbottom)\n\n    def setup(self, width=_CFG[\"width\"], height=_CFG[\"height\"],\n              startx=_CFG[\"leftright\"], starty=_CFG[\"topbottom\"]):\n        \"\"\" Set the size and position of the main window.\n        Arguments:\n        width: as integer a size in pixels, as float a fraction of the screen.\n          Default is 50% of screen.\n        height: as integer the height in pixels, as float a fraction of the\n          screen. Default is 75% of screen.\n        startx: if positive, starting position in pixels from the left\n          edge of the screen, if negative from the right edge\n          Default, startx=None is to center window horizontally.\n        starty: if positive, starting position in pixels from the top\n          edge of the screen, if negative from the bottom edge\n          Default, starty=None is to center window vertically.\n        Examples (for a Screen instance named screen):\n        >>> screen.setup (width=200, height=200, startx=0, starty=0)\n        sets window to 200x200 pixels, in upper left of screen\n        >>> screen.setup(width=.75, height=0.5, startx=None, starty=None)\n        sets window to 75% of screen by 50% of screen and centers\n        \"\"\"\n        if not hasattr(self._root, \"set_geometry\"):\n            return\n        sw = self._root.win_width()\n        sh = self._root.win_height()\n        if isinstance(width, float) and 0 <= width <= 1:\n            width = sw*width\n        if startx is None:\n            startx = (sw - width) \/ 2\n        if isinstance(height, float) and 0 <= height <= 1:\n            height = sh*height\n        if starty is None:\n            starty = (sh - height) \/ 2\n        self._root.set_geometry(width, height, startx, starty)\n        self.update()\n\n    def title(self, titlestring):\n        \"\"\"Set title of turtle-window\n        Argument:\n        titlestring -- a string, to appear in the titlebar of the\n                       turtle graphics window.\n        This is a method of Screen-class. Not available for TurtleScreen-\n        objects.\n        Example (for a Screen instance named screen):\n        >>> screen.title(\"Welcome to the turtle-zoo!\")\n        \"\"\"\n        if _Screen._root is not None:\n            _Screen._root.title(titlestring)\n        _Screen._title = titlestring\n\n    def _destroy(self):\n        root = self._root\n        if root is _Screen._root:\n            Turtle._pen = None\n            Turtle._screen = None\n            _Screen._root = None\n            _Screen._canvas = None\n        TurtleScreen._RUNNING = True\n        root.destroy()\n\n    def bye(self):\n        \"\"\"Shut the turtlegraphics window.\n        Example (for a TurtleScreen instance named screen):\n        >>> screen.bye()\n        \"\"\"\n        self._destroy()\n\n    def exitonclick(self):\n        \"\"\"Go into mainloop until the mouse is clicked.\n        No arguments.\n        Bind bye() method to mouseclick on TurtleScreen.\n        If \"using_IDLE\" - value in configuration dictionary is False\n        (default value), enter mainloop.\n        If IDLE with -n switch (no subprocess) is used, this value should be\n        set to True in turtle.cfg. In this case IDLE\'s mainloop\n        is active also for the client script.\n        This is a method of the Screen-class and not available for\n        TurtleScreen instances.\n        Example (for a Screen instance named screen):\n        >>> screen.exitonclick()\n        \"\"\"\n        def exitGracefully(x, y):\n            \"\"\"Screen.bye() with two dummy-parameters\"\"\"\n            self.bye()\n        self.onclick(exitGracefully)\n        if _CFG[\"using_IDLE\"]:\n            return\n        try:\n            mainloop()\n        except AttributeError:\n            exit(0)\n\n\nclass Turtle(RawTurtle):\n    \"\"\"RawTurtle auto-creating (scrolled) canvas.\n    When a Turtle object is created or a function derived from some\n    Turtle method is called a TurtleScreen object is automatically created.\n    \"\"\"\n    _pen = None\n    _screen = None\n\n    def __init__(self,\n                 shape=_CFG[\"shape\"],\n                 undobuffersize=_CFG[\"undobuffersize\"],\n                 visible=_CFG[\"visible\"]):\n        if Turtle._screen is None:\n            Turtle._screen = Screen()\n        RawTurtle.__init__(self, Turtle._screen,\n                           shape=shape,\n                           undobuffersize=undobuffersize,\n                           visible=visible)\n\nPen = Turtle\n\ndef _getpen():\n    \"\"\"Create the \'anonymous\' turtle if not already present.\"\"\"\n    if Turtle._pen is None:\n        Turtle._pen = Turtle()\n    return Turtle._pen\n\ndef _getscreen():\n    \"\"\"Create a TurtleScreen if not already present.\"\"\"\n    if Turtle._screen is None:\n        Turtle._screen = Screen()\n    return Turtle._screen\n\ndef write_docstringdict(filename=\"turtle_docstringdict\"):\n    \"\"\"Create and write docstring-dictionary to file.\n    Optional argument:\n    filename -- a string, used as filename\n                default value is turtle_docstringdict\n    Has to be called explicitly, (not used by the turtle-graphics classes)\n    The docstring dictionary will be written to the Python script <filname>.py\n    It is intended to serve as a template for translation of the docstrings\n    into different languages.\n    \"\"\"\n    docsdict = {}\n\n    for methodname in _tg_screen_functions:\n        key = \"_Screen.\"+methodname\n        docsdict[key] = eval(key).__doc__\n    for methodname in _tg_turtle_functions:\n        key = \"Turtle.\"+methodname\n        docsdict[key] = eval(key).__doc__\n\n    with open(\"%s.py\" % filename,\"w\") as f:\n        keys = sorted([x for x in docsdict.keys()\n                            if x.split(\'.\')[1] not in _alias_list])\n        f.write(\'docsdict = {\\n\\n\')\n        for key in keys[:-1]:\n            f.write(\'%s :\\n\' % repr(key))\n            f.write(\'        \"\"\"%s\\n\"\"\",\\n\\n\' % docsdict[key])\n        key = keys[-1]\n        f.write(\'%s :\\n\' % repr(key))\n        f.write(\'        \"\"\"%s\\n\"\"\"\\n\\n\' % docsdict[key])\n        f.write(\"}\\n\")\n        f.close()\n\ndef read_docstrings(lang):\n    \"\"\"Read in docstrings from lang-specific docstring dictionary.\n    Transfer docstrings, translated to lang, from a dictionary-file\n    to the methods of classes Screen and Turtle and - in revised form -\n    to the corresponding functions.\n    \"\"\"\n    modname = \"turtle_docstringdict_%(language)s\" % {\'language\':lang.lower()}\n    module = __import__(modname)\n    docsdict = module.docsdict\n    for key in docsdict:\n        try:\n#            eval(key).im_func.__doc__ = docsdict[key]\n            eval(key).__doc__ = docsdict[key]\n        except:\n            print(\"Bad docstring-entry: %s\" % key)\n\n_LANGUAGE = _CFG[\"language\"]\n\ntry:\n    if _LANGUAGE != \"english\":\n        read_docstrings(_LANGUAGE)\nexcept ImportError:\n    print(\"Cannot find docsdict for\", _LANGUAGE)\nexcept:\n    print (\"Unknown Error when trying to import %s-docstring-dictionary\" %\n                                                                  _LANGUAGE)\n\n\ndef getmethparlist(ob):\n    \"\"\"Get strings describing the arguments for the given object\n    Returns a pair of strings representing function parameter lists\n    including parenthesis.  The first string is suitable for use in\n    function definition and the second is suitable for use in function\n    call.  The \"self\" parameter is not included.\n    \"\"\"\n    defText = callText = \"\"\n    # bit of a hack for methods - turn it into a function\n    # but we drop the \"self\" param.\n    # Try and build one for Python defined functions\n    args, varargs, varkw = inspect.getargs(ob.__code__)\n    items2 = args[1:]\n    realArgs = args[1:]\n    defaults = ob.__defaults__ or []\n    defaults = [\"=%r\" % (value,) for value in defaults]\n    defaults = [\"\"] * (len(realArgs)-len(defaults)) + defaults\n    items1 = [arg + dflt for arg, dflt in zip(realArgs, defaults)]\n    if varargs is not None:\n        items1.append(\"*\" + varargs)\n        items2.append(\"*\" + varargs)\n    if varkw is not None:\n        items1.append(\"**\" + varkw)\n        items2.append(\"**\" + varkw)\n    defText = \", \".join(items1)\n    defText = \"(%s)\" % defText\n    callText = \", \".join(items2)\n    callText = \"(%s)\" % callText\n    return defText, callText\n\ndef _turtle_docrevise(docstr):\n    \"\"\"To reduce docstrings from RawTurtle class for functions\n    \"\"\"\n    import re\n    if docstr is None:\n        return None\n    turtlename = _CFG[\"exampleturtle\"]\n    newdocstr = docstr.replace(\"%s.\" % turtlename,\"\")\n    parexp = re.compile(r\' \\(.+ %s\\):\' % turtlename)\n    newdocstr = parexp.sub(\":\", newdocstr)\n    return newdocstr\n\ndef _screen_docrevise(docstr):\n    \"\"\"To reduce docstrings from TurtleScreen class for functions\n    \"\"\"\n    import re\n    if docstr is None:\n        return None\n    screenname = _CFG[\"examplescreen\"]\n    newdocstr = docstr.replace(\"%s.\" % screenname,\"\")\n    parexp = re.compile(r\' \\(.+ %s\\):\' % screenname)\n    newdocstr = parexp.sub(\":\", newdocstr)\n    return newdocstr\n\n## The following mechanism makes all methods of RawTurtle and Turtle available\n## as functions. So we can enhance, change, add, delete methods to these\n## classes and do not need to change anything here.\n\n\nfor methodname in _tg_screen_functions:\n    pl1, pl2 = getmethparlist(eval(\'_Screen.\' + methodname))\n    if pl1 == \"\":\n        print(\">>>>>>\", pl1, pl2)\n        continue\n    defstr = (\"def %(key)s%(pl1)s: return _getscreen().%(key)s%(pl2)s\" %\n                                   {\'key\':methodname, \'pl1\':pl1, \'pl2\':pl2})\n    exec(defstr)\n    eval(methodname).__doc__ = _screen_docrevise(eval(\'_Screen.\'+methodname).__doc__)\n\nfor methodname in _tg_turtle_functions:\n    pl1, pl2 = getmethparlist(eval(\'Turtle.\' + methodname))\n    if pl1 == \"\":\n        print(\">>>>>>\", pl1, pl2)\n        continue\n    defstr = (\"def %(key)s%(pl1)s: return _getpen().%(key)s%(pl2)s\" %\n                                   {\'key\':methodname, \'pl1\':pl1, \'pl2\':pl2})\n    exec(defstr)\n    eval(methodname).__doc__ = _turtle_docrevise(eval(\'Turtle.\'+methodname).__doc__)\n\n\ndone = mainloop\n\nif __name__ == \"__main__\":\n    def switchpen():\n        if isdown():\n            pu()\n        else:\n            pd()\n\n    def demo1():\n        \"\"\"Demo of old turtle.py - module\"\"\"\n        reset()\n        tracer(True)\n        up()\n        backward(100)\n        down()\n        # draw 3 squares; the last filled\n        width(3)\n        for i in range(3):\n            if i == 2:\n                begin_fill()\n            for _ in range(4):\n                forward(20)\n                left(90)\n            if i == 2:\n                color(\"maroon\")\n                end_fill()\n            up()\n            forward(30)\n            down()\n        width(1)\n        color(\"black\")\n        # move out of the way\n        tracer(False)\n        up()\n        right(90)\n        forward(100)\n        right(90)\n        forward(100)\n        right(180)\n        down()\n        # some text\n        write(\"startstart\", 1)\n        write(\"start\", 1)\n        color(\"red\")\n        # staircase\n        for i in range(5):\n            forward(20)\n            left(90)\n            forward(20)\n            right(90)\n        # filled staircase\n        tracer(True)\n        begin_fill()\n        for i in range(5):\n            forward(20)\n            left(90)\n            forward(20)\n            right(90)\n        end_fill()\n        # more text\n\n    def demo2():\n        \"\"\"Demo of some new features.\"\"\"\n        speed(1)\n        st()\n        pensize(3)\n        setheading(towards(0, 0))\n        radius = distance(0, 0)\/2.0\n        rt(90)\n        for _ in range(18):\n            switchpen()\n            circle(radius, 10)\n        write(\"wait a moment...\")\n        while undobufferentries():\n            undo()\n        reset()\n        lt(90)\n        colormode(255)\n        laenge = 10\n        pencolor(\"green\")\n        pensize(3)\n        lt(180)\n        for i in range(-2, 16):\n            if i > 0:\n                begin_fill()\n                fillcolor(255-15*i, 0, 15*i)\n            for _ in range(3):\n                fd(laenge)\n                lt(120)\n            end_fill()\n            laenge += 10\n            lt(15)\n            speed((speed()+1)%12)\n        #end_fill()\n\n        lt(120)\n        pu()\n        fd(70)\n        rt(30)\n        pd()\n        color(\"red\",\"yellow\")\n        speed(0)\n        begin_fill()\n        for _ in range(4):\n            circle(50, 90)\n            rt(90)\n            fd(30)\n            rt(90)\n        end_fill()\n        lt(90)\n        pu()\n        fd(30)\n        pd()\n        shape(\"turtle\")\n\n        tri = getturtle()\n        tri.resizemode(\"auto\")\n        turtle = Turtle()\n        turtle.resizemode(\"auto\")\n        turtle.shape(\"turtle\")\n        turtle.reset()\n        turtle.left(90)\n        turtle.speed(0)\n        turtle.up()\n        turtle.goto(280, 40)\n        turtle.lt(30)\n        turtle.down()\n        turtle.speed(6)\n        turtle.color(\"blue\",\"orange\")\n        turtle.pensize(2)\n        tri.speed(6)\n        setheading(towards(turtle))\n        count = 1\n        while tri.distance(turtle) > 4:\n            turtle.fd(3.5)\n            turtle.lt(0.6)\n            tri.setheading(tri.towards(turtle))\n            tri.fd(4)\n            if count % 20 == 0:\n                turtle.stamp()\n                tri.stamp()\n                switchpen()\n            count += 1\n        tri.write(\"CAUGHT! \", font=(\"Arial\", 16, \"bold\"), align=\"right\")\n        tri.pencolor(\"black\")\n        tri.pencolor(\"red\")\n\n        def baba(xdummy, ydummy):\n            clearscreen()\n            bye()\n\n        time.sleep(2)\n\n        while undobufferentries():\n            tri.undo()\n            turtle.undo()\n        tri.fd(50)\n        tri.write(\"  Click me!\", font = (\"Courier\", 12, \"bold\") )\n        tri.onclick(baba, 1)\n\n    demo1()\n    demo2()\n    exitonclick()'
      }
    });

    let INITIAL_DATA = ce;
    let USER_DATA = {
      username: request.pre.user.username
    };

    reply.view('embed', {
      authToken,
      server: Config.sourcebox.url,
      INITIAL_DATA: JSON.stringify(INITIAL_DATA),
      USER_DATA: JSON.stringify(USER_DATA)
    });
  }
};
